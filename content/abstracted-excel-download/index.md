---
emoji: ğŸ“–
title: ì•„ ì—‘ì…€ë‹¤ìš´ë¡œë“œ ê°œë°œ,,, ì‰½ê³  ë¹ ë¥´ê²Œ í•˜ê³  ì‹¶ë‹¤ (feat. ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ëª¨ë“ˆ ê°œë°œê¸°)
date: '2025-01-06 20:30:15'
author: ì—ë””
categories: aop
---

## ì•„ ì—‘ì…€ë‹¤ìš´ë¡œë“œ ê°œë°œ,,, ì‰½ê³  ë¹ ë¥´ê²Œ í•˜ê³  ì‹¶ë‹¤ (feat. ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ëª¨ë“ˆ ê°œë°œê¸°)

## ğŸ“Œ ë“¤ì–´ê°€ë©°

ì—¬ëŸ¬ë¶„ë„ í•œ ë²ˆì¯¤ì€ ëŒ€ëŸ‰ì˜ ë°ì´í„°ë¥¼ ì—‘ì…€ë¡œ ë½‘ì•„ì•¼ í•˜ëŠ” ìˆœê°„ì„ ë§ì´í•´ë³¸ ì  ìˆì£ ?
â€œì´ê±° ë˜ ë°˜ë³µ ì‘ì—…ì¸ê°€â€¦â€ í•˜ë©° í•œìˆ¨ì´ ì ˆë¡œ ë‚˜ì˜¤ëŠ” ê·¸ ê¸°ë¶„!
ì €ëŠ” ì´ ê·€ì°®ìŒì„ ë‹¨ì¶•ì‹œí‚¤ê³ , ë” ê¹”ë”í•œ ì½”ë“œë¥¼ ë‚¨ê¸°ê³  ì‹¶ì–´ì„œ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ëª¨ë“ˆì„ ì§ì ‘ ë§Œë“¤ì–´ ë³´ê¸°ë¡œ í–ˆìŠµë‹ˆë‹¤.
ë¹„ìŠ·í•œ ë¶ˆí¸ì„ ê²ªê³  ê³„ì‹  ë¶„ë“¤ê»˜ ì‘ì€ íŒíŠ¸ë¼ë„ ë˜ê¸¸ ë°”ë¼ë©°, ì¬ë¯¸ìˆê²Œ í’€ì–´ë³¼ê²Œìš”!

### ì™œ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ëª¨ë“ˆì„ ë§Œë“¤ê²Œ ë˜ì—ˆë‚˜?
    - ì¤‘ë³µ ì½”ë“œì˜ ì§€ì˜¥
    ë§¤ë²ˆ ì»¨íŠ¸ë¡¤ëŸ¬ë§ˆë‹¤ Workbook, Sheet, CellStyleì„ ì¼ì¼ì´ ì„¸íŒ…í•˜ë‹¤ ë³´ë‹ˆ, ì–´ëŠìƒˆ ì½”ë“œê°€ ì‚¬ë°©íŒ”ë°© í©ì–´ì ¸ ë²„ë ¸ìŠµë‹ˆë‹¤.
	- ìš”êµ¬ì‚¬í•­ ë³€ê²½ì˜ íŒŒë„:
    - â€œì´ë²ˆì—” í—¤ë” ìƒ‰ê¹” ì¢€ ë°”ê¿”ì£¼ì„¸ìš”.â€ â€œì…€ ë³‘í•©ë„ ì¢€ í•´ì£¼ì„¸ìš”.â€
ì‘ì€ ìš”êµ¬ í•˜ë‚˜ê°€ ìƒê¸¸ ë•Œë§ˆë‹¤ ì¥ë¬¸ì˜ ì½”ë“œë¥¼ ì½ì–´ì•¼ í•˜ë‹ˆ ë‹µë‹µí–ˆìŠµë‹ˆë‹¤.

â€œí•œ ë²ˆë§Œ ë§Œë“¤ì–´ ë†“ê³  ê³„ì† ì¨ë¨¹ì!â€
ì´ ê°„ì ˆí•¨ì´ ëª¨ë“ˆ ê°œë°œì˜ ì¶œë°œì ì´ì—ˆìŠµë‹ˆë‹¤.

### ì•„ì£¼ ë§ì€ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ
PGì‚¬ì˜ ë°±ì˜¤í”¼ìŠ¤ì—ì„œëŠ” ê°€ë§¹ì  í˜¹ì€ íšŒê³„íŒ€, ì¬ë¬´íŒ€ ë“±ì—ì„œ
ê±°ë˜ ëª©ë¡, ë§¤ì… ëª©ë¡, ì •ì‚° ëª©ë¡ ë“±ë“± ì´ 50ê°œê°€ ë„˜ëŠ” ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥ì´ ì¡´ì¬í–ˆìŠµë‹ˆë‹¤.

![ì—‘ì…€](https://techblog.woowahan.com/wp-content/uploads/img/2020-10-08/a-lot-of-excels.png)

ê·¸ë¦¬ê³  ë°ì´í„°ì˜ ì–‘ì€ ì‹¬í•˜ë©´ 30ë§Œ Row í˜¹ì€ ê·¸ ì´ìƒì˜ ë°ì´í„°ë“¤ì„ ì—‘ì…€ì— ë„£ì–´ì¤˜ì•¼ í–ˆìŠµë‹ˆë‹¤.

í˜„ì¬ì™€ ê°™ì€ ì—‘ì…€ ê°œë°œ ë°©ë²•ìœ¼ë¡œëŠ” ìƒì‚°ì„±ì´ ë‹¤ì†Œ ë–¨ì–´ì§„ë‹¤ê³  íŒë‹¨í•˜ì˜€ìŠµë‹ˆë‹¤.

ê·¸ë¦¬í•˜ì—¬ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥ ê°œë°œì˜ ìƒì‚°ì„±ì„ ì˜¬ë ¤ì¤„ ê°„ë‹¨í•œ ëª¨ë“ˆì„ ë§Œë“¤ì–´ì•¼ê² ë‹¤ê³  ìƒê°í–ˆëŠ”ë°ìš”, ê¸°ì¡´ì—ëŠ” ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ê°œë°œ ê¸°ëŠ¥ì„ ì–´ë–»ê²Œ êµ¬í˜„í•˜ê³  ìˆì—ˆëŠ”ì§€ ê°€ì¥ ê¸°ë³¸ì ì¸ í˜•íƒœë¶€í„° ì†Œê°œí•´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

## ì´ˆê¸° ë²„ì „(POIë¥¼ ì´ìš©í•œ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ê°œë°œ)

```java
@GetMapping("/api/v1/car")
public void downloadCarInfo(HttpServletResponse response) throws IOException {
  // ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ê³  Workbook, Sheetë¥¼ ë§Œë“­ë‹ˆë‹¤
  CellStyle greyCellStyle = workbook.createCellStyle();
  applyCellStyle(greyCellStyle, new Color(231, 234, 236));

  CellStyle blueCellStyle = workbook.createCellStyle();
  applyCellStyle(blueCellStyle, new Color(223, 235, 246));

  CellStyle bodyCellStyle = workbook.createCellStyle();
  applyCellStyle(bodyCellStyle, new Color(255, 255, 255));

  // í—¤ë”ë¥¼ ìƒì„±í•©ë‹ˆë‹¤
  int rowIndex = 0;
  Row headerRow = sheet.createRow(rowIndex++);
  Cell headerCell1 = headerRow.createCell(0);
  headerCell1.setCellValue("íšŒì‚¬");
  headerCell1.setCellStyle(greyCellStyle); // styleì„ ì§€ì •í•´ì£¼ëŠ” ì½”ë“œ ì¶”ê°€

  /* ë‚˜ë¨¸ì§€ í—¤ë” ë Œë”ë§ì„ ìœ„í•œ ë°˜ë³µ ìƒëµ */

  // ë°”ë””ì— ë°ì´í„°ë¥¼ ë„£ì–´ì¤ë‹ˆë‹¤
  for (CarExcelDto dto : carExcelDtos) {
    Row bodyRow = sheet.createRow(rowIndex++);

    Cell bodyCell1 = bodyRow.createCell(0);
    bodyCell1.setCellValue(dto.getCompany());
    bodyCell1.setCellStyle(bodyCellStyle);

    /**
     * ë‚˜ë¨¸ì§€ ë°”ë”” ë Œë”ë§ì„ ìœ„í•œ ë°˜ë³µ ìƒëµ 
     * int íƒ€ì…ê³¼ double íƒ€ì…ì— ëŒ€í•œ DataFormat ì„¤ì •ì´ ì¶”ê°€ì ìœ¼ë¡œ ìˆìŠµë‹ˆë‹¤
     */ 
  }

  // OutputStreamì— ì—‘ì…€ sheet ë°ì´í„° ì“°ê¸°
}

private void applyCellStyle(CellStyle cellStyle, Color color) {
  XSSFCellStyle xssfCellStyle = (XSSFCellStyle) cellStyle;
  xssfCellStyle.setFillForegroundColor(new XSSFColor(color, new DefaultIndexedColorMap()));
  cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);
  cellStyle.setAlignment(HorizontalAlignment.CENTER);
  cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);
  cellStyle.setBorderLeft(BorderStyle.THIN);
  cellStyle.setBorderTop(BorderStyle.THIN);
  cellStyle.setBorderRight(BorderStyle.THIN);
  cellStyle.setBorderBottom(BorderStyle.THIN);
}
```

![ì—‘ì…€2](https://techblog.woowahan.com/wp-content/uploads/img/2020-10-08/excel-example-2.png)

ìƒˆë¡œìš´ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥ì„ êµ¬í˜„í• ë•Œë§ˆë‹¤ ì´ëŸ° ì½”ë“œê°€ ë°˜ë³µëœë‹¤ê³  ìƒê°í•˜ë‹ˆ ë”ì°í•©ë‹ˆë‹¤â€¦ ìœ¼â€¦

## ìƒˆë¡œìš´ ì—‘ì…€ëª¨ë“ˆ ê°œë°œí•˜ê¸°

- ìˆ˜ì‹­ë§Œ ê±´ì˜ ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬
- ë‹¤ì¤‘ ì‹œíŠ¸ì™€ ì‹œíŠ¸ë³„ ë‹¤ë¥¸ ì‹œì‘ ìœ„ì¹˜
- ì½”ë“œê°’ ë³€í™˜, ë‚ ì§œ í¬ë§· ë“± ë³µì¡í•œ ë°ì´í„° ë³€í™˜
- í•„ìˆ˜ê°’ ê²€ì¦ ë° ì—ëŸ¬ ì²˜ë¦¬
- ë‹¤êµ­ì–´ ì§€ì› ë° ì¼ê´€ëœ ê¸°ì—… ìŠ¤íƒ€ì¼ ì ìš©

### ì–´ë…¸í…Œì´ì…˜ê³¼ ë¦¬í”Œë ‰ì…˜ì„ ì´ìš©í•˜ì—¬ ê°„í¸í•˜ê²Œ!
ì²« ë²ˆì§¸ ëª©í‘œëŠ” Columnì— getterë¥¼ ì‚¬ìš©í•´ Cellì„ í•˜ë‚˜ì”© ë§Œë“¤ì–´ì¤„ í•„ìš”ê°€ ì—†ë„ë¡ í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ ëª©í‘œë¥¼ ìœ„í•´ JAVAì— ì¡´ì¬í•˜ëŠ” ì–´ë…¸í…Œì´ì…˜ê³¼ ë¦¬í”Œë ‰ì…˜ì„ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì œê°€ êµ¬ìƒí•œ ë°©ë²•ì€, JPAì—ì„œ DB columnì„ @Columnìœ¼ë¡œ í‘œì‹œí•˜ëŠ” ê²ƒê³¼ ë¹„ìŠ·í•˜ê²Œ DTOì—ì„œ ì—‘ì…€ì— í‘œì‹œí•˜ê³  ì‹¶ì€ í•„ë“œë¥¼ @ExcelColum ìœ¼ë¡œ í‘œì‹œí•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

## 1. ì™œ 'ë‹¨ìˆœ AOP'ë§Œìœ¼ë¡œëŠ” ë¶€ì¡±í• ê¹Œ?
ë‹¨ì¼ ì‹œíŠ¸, ì†ŒëŸ‰ ë°ì´í„°ì— ëŒ€í•´ì„œëŠ” ê°„ë‹¨í•œ `@ExcelDocument` ì• ë…¸í…Œì´ì…˜ ê¸°ë°˜ AOP ì²˜ë¦¬ê°€ ì¶©ë¶„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì‹¤ì œ ì„œë¹„ìŠ¤ í™˜ê²½ì—ì„œëŠ” ì´ë³´ë‹¤ í›¨ì”¬ ë³µì¡í•œ ìš”êµ¬ì‚¬í•­ì´ ì¡´ì¬í•©ë‹ˆë‹¤.

- **ëŒ€ìš©ëŸ‰ ë°ì´í„°**: 100ë§Œ ê±´ ì´ìƒì˜ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•´ì•¼ í•  ë•Œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¬¸ì œ
- **ë‹¤ì¤‘ ì‹œíŠ¸**: ë³´ê³ ì„œë§ˆë‹¤ ì—¬ëŸ¬ ê°œì˜ ì‹œíŠ¸, ê° ì‹œíŠ¸ë§ˆë‹¤ ì„œë¡œ ë‹¤ë¥¸ DTO ë§¤í•‘ í•„ìš”
- **ë°ì´í„° ë³€í™˜**: í•„ë“œ ê°’ì— ë”°ë¼ ì½”ë“œâ†’ë¬¸êµ¬ ë³€í™˜, ì»¤ìŠ¤í…€ ë‚ ì§œ í¬ë§· ë“± ë¡œì§ í•„ìš”
- **ë°ì´í„° ê²€ì¦**: íŠ¹ì • ì»¬ëŸ¼ì´ ë¹„ì–´ ìˆìœ¼ë©´ ì—ëŸ¬ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ê²€ì¦ ë¡œì§ í•„ìš”
- **ë‹¤êµ­ì–´ ì§€ì›**: í—¤ë” í…ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©ìì˜ Localeì— ë”°ë¼ ë³€ê²½í•´ì•¼ í•¨
- **í‘œì¤€ ìŠ¤íƒ€ì¼ë§**: íšŒì‚¬ ê¸°ë³¸ ìŠ¤íƒ€ì¼(í°íŠ¸Â·í…Œë‘ë¦¬Â·ì»¬ëŸ¬)ì„ ì „ì—­ ì„¤ì •ìœ¼ë¡œ ê´€ë¦¬

ì´ëŸ¬í•œ ìš”êµ¬ì‚¬í•­ì„ ë‹¨ì¼ AOP ì–´ë“œë°”ì´ìŠ¤ë¡œ ë¬¶ì–´ ì²˜ë¦¬í•˜ë©´, ì½”ë“œê°€ ë³µì¡í•´ì§€ê³  ìœ ì§€ë³´ìˆ˜ê°€ ì–´ë ¤ì›Œì§‘ë‹ˆë‹¤. ë”°ë¼ì„œ ëª¨ë“ˆí™”, í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜, ìŠ¤íŠ¸ë¦¬ë° ì—”ì§„ ë“±ì„ í¬í•¨í•œ í™•ì¥ ê°€ëŠ¥í•œ ì„¤ê³„ê°€ í•„ìš”í•©ë‹ˆë‹¤.

## 2. ì•„í‚¤í…ì²˜ ê°œìš”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ExcelStarter                         â”‚
â”‚  (Spring Boot Autoâ€‘Configuration + application.yml)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Core       â”‚  Streaming  â”‚  Plugin      â”‚  i18n     â”‚
â”‚  - Annotation â”‚  Engine     â”‚  - Converter â”‚ Resolver  â”‚
â”‚  - Builder    â”‚ SXSSF ê¸°ë°˜   â”‚  - Validator â”‚           â”‚
â”‚  - Metadata   â”‚             â”‚  - Formatter â”‚           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.1. Core ëª¨ë“ˆ
- @ExcelDocument, @SheetConfig ë“± ì• ë…¸í…Œì´ì…˜ ì •ì˜
- ExcelBuilder API, AOP ì§€ì›
- DTO ë©”íƒ€ë°ì´í„° ì¶”ì¶œÂ·ê´€ë¦¬

### 2.2. Streaming Engine
- Apache POIì˜ SXSSFWorkbook ê¸°ë°˜ìœ¼ë¡œ ë©”ëª¨ë¦¬ì— ìƒìœ„ 100í–‰ë§Œ ìœ ì§€

### 2.3. Plugin ëª¨ë“ˆ
- ValueConverter: íŠ¹ì • í•„ë“œ ê°’ ë³€í™˜ (ì˜ˆ: ì½”ë“œâ†’í…ìŠ¤íŠ¸)
- Validator: DTO í•„ìˆ˜ê°’Â·í¬ë§· ê²€ì¦
- Formatter: ì‚¬ìš©ì ì •ì˜ í¬ë§· ì ìš© (ì˜ˆ: ì „í™”ë²ˆí˜¸, ìš°í¸ë²ˆí˜¸)

### 2.4. i18n & Global Config
- messages_{locale}.properties íŒŒì¼ì—ì„œ í—¤ë” í…ìŠ¤íŠ¸ ì¡°íšŒ
- application.ymlë¡œ ê¸°ë³¸ ìŠ¤íƒ€ì¼Â·ì—”ì§„ íƒ€ì…Â·í…œí¬ëŸ´ í¬ë§· ì§€ì •

## 3. Core ëª¨ë“ˆ â€“ ì• ë…¸í…Œì´ì…˜ê³¼ Builder

### 3.1. ì• ë…¸í…Œì´ì…˜ í™•ì¥

```java
/**
 * ì—‘ì…€ ë¬¸ì„œë¥¼ ì •ì˜í•˜ëŠ” ìµœìƒìœ„ ì• ë…¸í…Œì´ì…˜
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ExcelDocument {
    /**
     * ë‹¤ìš´ë¡œë“œí•  ì—‘ì…€ íŒŒì¼ëª…
     */
    String fileName();
    
    /**
     * ë¬¸ì„œ ë‚´ ì‹œíŠ¸ êµ¬ì„± ì •ë³´
     */
    SheetConfig[] sheets() default {};
    
    /**
     * í…œí”Œë¦¿ íŒŒì¼ ê²½ë¡œ (ì„ íƒ ì‚¬í•­)
     * í…œí”Œë¦¿ ë¯¸ì§€ì • ì‹œ ë¹ˆ ë¬¸ì„œì—ì„œ ì‹œì‘
     */
    String template() default "";
}

/**
 * ì‹œíŠ¸ë³„ ì„¤ì • ì •ë³´
 */
@Target({})
@Retention(RetentionPolicy.RUNTIME)
public @interface SheetConfig {
    /**
     * ì‹œíŠ¸ëª…
     */
    String name();
    
    /**
     * ë§¤í•‘í•  DTO í´ë˜ìŠ¤
     */
    Class<?> dto();
    
    /**
     * ì‹œíŠ¸ë³„ ê°œë³„ í…œí”Œë¦¿(ì„ íƒ)
     * ì‹œíŠ¸ë³„ë¡œ ì„œë¡œ ë‹¤ë¥¸ í…œí”Œë¦¿ ì ìš© ê°€ëŠ¥
     */
    String template() default "";
    
    /**
     * í—¤ë” ì‹œì‘ ìœ„ì¹˜ (ê¸°ë³¸ê°’: A2)
     */
    String startCell() default "A2";
    
    /**
     * ë°ì´í„° í–‰ ì‹œì‘ ìœ„ì¹˜ (ê¸°ë³¸ê°’: startCell ê¸°ì¤€ +1)
     */
    String dataStartCell() default "";
}

/**
 * DTO í•„ë“œì— ì ìš©í•˜ëŠ” ì»¬ëŸ¼ ë§¤í•‘ ì• ë…¸í…Œì´ì…˜
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ExcelColumn {
    /**
     * ì»¬ëŸ¼ ìˆœì„œ (0ë¶€í„° ì‹œì‘)
     */
    int order();
    
    /**
     * í—¤ë” í…ìŠ¤íŠ¸ (ì§ì ‘ ì§€ì • ì‹œ)
     */
    String header() default "";
    
    /**
     * ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ í‚¤ (messages.properties)
     */
    String headerKey() default "";
    
    /**
     * ì»¬ëŸ¼ ë„ˆë¹„ (ê¸°ë³¸ê°’ -1: ìë™)
     */
    int width() default -1;
    
    /**
     * ì…€ ìŠ¤íƒ€ì¼ (í—¤ë”)
     */
    ExcelCellStyle headerStyle() default @ExcelCellStyle;
    
    /**
     * ì…€ ìŠ¤íƒ€ì¼ (ë°ì´í„°)
     */
    ExcelCellStyle dataStyle() default @ExcelCellStyle;
}

/**
 * ì…€ ìŠ¤íƒ€ì¼ ì •ì˜
 */
@Target({})
@Retention(RetentionPolicy.RUNTIME)
public @interface ExcelCellStyle {
    /**
     * í°íŠ¸ ì´ë¦„
     */
    String fontName() default "";
    
    /**
     * í°íŠ¸ í¬ê¸°
     */
    short fontSize() default -1;
    
    /**
     * í°íŠ¸ ìƒ‰ìƒ (e.g., "#FF0000")
     */
    String fontColor() default "";
    
    /**
     * ë°°ê²½ ìƒ‰ìƒ (e.g., "#FFFFCC")
     */
    String bgColor() default "";
    
    /**
     * êµµê²Œ
     */
    boolean bold() default false;
    
    /**
     * ê°€ë¡œ ì •ë ¬
     */
    HAlign hAlign() default HAlign.DEFAULT;
    
    /**
     * ì„¸ë¡œ ì •ë ¬
     */
    VAlign vAlign() default VAlign.DEFAULT;
    
    /**
     * í…Œë‘ë¦¬ (ì „ì²´)
     */
    BorderStyle border() default BorderStyle.DEFAULT;
    
    /**
     * ìë™ ì¤„ë°”ê¿ˆ
     */
    boolean wrapText() default false;
    
    enum HAlign { DEFAULT, LEFT, CENTER, RIGHT }
    enum VAlign { DEFAULT, TOP, MIDDLE, BOTTOM }
    enum BorderStyle { DEFAULT, NONE, THIN, MEDIUM, THICK }
}
```

ì´ ì• ë…¸í…Œì´ì…˜ ì„¸íŠ¸ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤:

- `@ExcelDocument.sheets`ë¡œ ë‹¤ì¤‘ ì‹œíŠ¸ ì •ì˜
- ì‹œíŠ¸ë³„ `template`ì„ ì§€ì •í•´ í…œí”Œë¦¿ í˜¼í•© ì‚¬ìš©
- `startCell`ë¡œ í—¤ë” ìœ„ì¹˜ ììœ ë¡­ê²Œ ì§€ì •
- ì»¬ëŸ¼ë³„ ìŠ¤íƒ€ì¼, ë„ˆë¹„, ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ í‚¤ ë“± ì„¤ì • ê°€ëŠ¥

### 3.2. Builder API

```java
/**
 * ì—‘ì…€ ë¬¸ì„œ ìƒì„±ì„ ìœ„í•œ ë¹Œë” ì¸í„°í˜ì´ìŠ¤
 */
public interface ExcelBuilder {
    /**
     * ë¹Œë” ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
     */
    static ExcelBuilder create() {
        return new ExcelBuilderImpl();
    }

    /**
     * ì—‘ì…€ ë¬¸ì„œ í´ë˜ìŠ¤ ì§€ì •
     */
    ExcelBuilder document(Class<?> docClass);
    
    /**
     * ì‹œíŠ¸ë³„ ë°ì´í„° ì¶”ê°€
     */
    ExcelBuilder sheetData(String sheetName, List<?> data);
    
    /**
     * ë‹¤êµ­ì–´ Locale ì„¤ì •
     */
    ExcelBuilder locale(Locale locale);
    
    /**
     * ê°’ ë³€í™˜ê¸° ì¶”ê°€ (ë‹¨ì¼)
     */
    ExcelBuilder addConverter(ValueConverter converter);
    
    /**
     * ê°’ ë³€í™˜ê¸° ì¶”ê°€ (ë‹¤ì¤‘)
     */
    ExcelBuilder addConverters(Collection<ValueConverter> converters);
    
    /**
     * ê°’ ë³€í™˜ê¸° ì¶”ê°€ (ê°€ë³€ ì¸ì)
     */
    ExcelBuilder addConverters(ValueConverter... converters);
    
    /**
     * ê²€ì¦ê¸° ì¶”ê°€ (ë‹¨ì¼)
     */
    ExcelBuilder addValidator(Validator validator);
    
    /**
     * ê²€ì¦ê¸° ì¶”ê°€ (ë‹¤ì¤‘)
     */
    ExcelBuilder addValidators(Collection<Validator> validators);
    
    /**
     * ê²€ì¦ê¸° ì¶”ê°€ (ê°€ë³€ ì¸ì)
     */
    ExcelBuilder addValidators(Validator... validators);
    
    /**
     * ì»¤ìŠ¤í…€ ì…€ ìŠ¤íƒ€ì¼ ì¶”ê°€
     */
    ExcelBuilder addCellStyle(String name, CellStyle style);
    
    /**
     * i18n ë¦¬ì¡¸ë²„ ì„¤ì •
     */
    ExcelBuilder i18nResolver(I18nResolver resolver);
    
    /**
     * ë¬¸ì„œ ì‘ì„± ë° ì¶œë ¥
     */
    void write(OutputStream os) throws IOException;
}

/**
 * ExcelBuilder êµ¬í˜„ì²´
 */
public class ExcelBuilderImpl implements ExcelBuilder {
    private Class<?> documentClass;
    private Map<String, List<?>> sheetDataMap = new HashMap<>();
    private Locale locale = Locale.getDefault();
    private List<ValueConverter> converters = new ArrayList<>();
    private List<Validator> validators = new ArrayList<>();
    private Map<String, CellStyle> namedStyles = new HashMap<>();
    private I18nResolver i18nResolver;
    private ExcelEngine engine;
    
    public ExcelBuilderImpl() {
        // ê¸°ë³¸ ì„¤ì •ì—ì„œ ì—”ì§„ íƒ€ì… ê²°ì •
        this.engine = determineEngine();
    }
    
    private ExcelEngine determineEngine() {
        // application.yml ì„¤ì •ì— ë”°ë¼ ìŠ¤íŠ¸ë¦¬ë° ë˜ëŠ” ì¸ë©”ëª¨ë¦¬ ì—”ì§„ ì„ íƒ
        return ExcelEngineFactory.create();
    }
    
    @Override
    public ExcelBuilder document(Class<?> docClass) {
        this.documentClass = docClass;
        return this;
    }
    
    @Override
    public ExcelBuilder sheetData(String sheetName, List<?> data) {
        this.sheetDataMap.put(sheetName, data);
        return this;
    }
    
    @Override
    public ExcelBuilder locale(Locale locale) {
        this.locale = locale;
        return this;
    }
    
    @Override
    public ExcelBuilder addConverter(ValueConverter converter) {
        this.converters.add(converter);
        return this;
    }
    
    @Override
    public ExcelBuilder addConverters(Collection<ValueConverter> converters) {
        if (converters != null) {
            this.converters.addAll(converters);
        }
        return this;
    }
    
    @Override
    public ExcelBuilder addConverters(ValueConverter... converters) {
        if (converters != null) {
            this.converters.addAll(Arrays.asList(converters));
        }
        return this;
    }
    
    @Override
    public ExcelBuilder addValidator(Validator validator) {
        this.validators.add(validator);
        return this;
    }
    
    @Override
    public ExcelBuilder addValidators(Collection<Validator> validators) {
        if (validators != null) {
            this.validators.addAll(validators);
        }
        return this;
    }
    
    @Override
    public ExcelBuilder addValidators(Validator... validators) {
        if (validators != null) {
            this.validators.addAll(Arrays.asList(validators));
        }
        return this;
    }
    
    @Override
    public ExcelBuilder addCellStyle(String name, CellStyle style) {
        this.namedStyles.put(name, style);
        return this;
    }
    
    @Override
    public ExcelBuilder i18nResolver(I18nResolver resolver) {
        this.i18nResolver = resolver;
        return this;
    }
    
    @Override
    public void write(OutputStream os) throws IOException {
        // 1. ë¬¸ì„œ ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
        ExcelMeta meta = MetadataExtractor.extract(documentClass);
        
        // 2. ë°ì´í„° ê²€ì¦
        validateData(meta);
        
        // 3. ì—”ì§„ì— ì²˜ë¦¬ ìœ„ì„
        I18nResolver resolverToUse = i18nResolver != null ? 
            i18nResolver : ExcelContextHolder.getDefaultI18nResolver();
            
        engine.export(meta, sheetDataMap, converters, resolverToUse, locale, os);
    }
    
    private void validateData(ExcelMeta meta) {
        // ì‹œíŠ¸ë³„ ë°ì´í„° ê²€ì¦
        for (SheetMeta sheetMeta : meta.getSheets()) {
            String sheetName = sheetMeta.getName();
            List<?> data = sheetDataMap.get(sheetName);
            
            if (data == null) {
                throw new ExcelException("No data provided for sheet: " + sheetName);
            }
            
            // ê° ë°ì´í„° í•­ëª© ê²€ì¦
            for (Object dto : data) {
                for (Validator validator : validators) {
                    validator.validate(dto);
                }
            }
        }
    }
}
```

ì´ ë¹Œë” APIëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤
- ëª…ì‹œì  í˜¸ì¶œ ë°©ì‹ìœ¼ë¡œ AOP ì—†ì´ë„ ì‚¬ìš© ê°€ëŠ¥
- `sheetData()` í˜¸ì¶œ ìˆœì„œì™€ `SheetConfig.name()` ë§¤í•‘
- `locale()`ë¡œ ë‹¤êµ­ì–´ í—¤ë” ìë™ ì ìš©
- í”ŒëŸ¬ê·¸ì¸(ì»¨ë²„í„°Â·ê²€ì¦ê¸°) ì§ì ‘ ë“±ë¡ ê°€ëŠ¥ - ë‹¨ì¼, ì»¬ë ‰ì…˜, ê°€ë³€ì¸ì í˜•ì‹ ì§€ì›
- ì—”ì§„ íƒ€ì… ìë™ ê²°ì • (ì„¤ì •ì— ë”°ë¼)
- ì»¤ìŠ¤í…€ i18n ë¦¬ì¡¸ë²„ ì„¤ì • ê°€ëŠ¥

### 3.3. ë©”íƒ€ë°ì´í„° ì¶”ì¶œ

```java
/**
 * ì—‘ì…€ ë¬¸ì„œ ë©”íƒ€ë°ì´í„°
 */
public class ExcelMeta {
    private String fileName;
    private String template;
    private List<SheetMeta> sheets = new ArrayList<>();
    
    // getters and setters
}

/**
 * ì‹œíŠ¸ ë©”íƒ€ë°ì´í„°
 */
public class SheetMeta {
    private String name;
    private Class<?> dtoClass;
    private String template;
    private CellReference startCell;
    private CellReference dataStartCell;
    private List<ColumnMeta> columns = new ArrayList<>();
    
    // startRow, startCol ë“± í¸ì˜ ë©”ì„œë“œë“¤
    public int getStartRow() {
        return startCell.getRow();
    }
    
    public int getStartCol() {
        return startCell.getCol();
    }
    
    // getters and setters
}

/**
 * ì»¬ëŸ¼ ë©”íƒ€ë°ì´í„°
 */
public class ColumnMeta {
    private Field field;
    private int order;
    private String header;
    private String headerKey;
    private int width;
    private ExcelCellStyle headerStyle;
    private ExcelCellStyle dataStyle;
    
    // getters and setters
}

/**
 * ë©”íƒ€ë°ì´í„° ì¶”ì¶œê¸°
 */
public class MetadataExtractor {
    
    public static ExcelMeta extract(Class<?> documentClass) {
        ExcelMeta meta = new ExcelMeta();
        
        // 1. @ExcelDocument ì• ë…¸í…Œì´ì…˜ ì²˜ë¦¬
        if (!documentClass.isAnnotationPresent(ExcelDocument.class)) {
            throw new ExcelException("Class is not annotated with @ExcelDocument");
        }
        
        ExcelDocument docAnno = documentClass.getAnnotation(ExcelDocument.class);
        meta.setFileName(docAnno.fileName());
        meta.setTemplate(docAnno.template());
        
        // 2. ì‹œíŠ¸ ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
        for (SheetConfig sheetConfig : docAnno.sheets()) {
            SheetMeta sheetMeta = new SheetMeta();
            sheetMeta.setName(sheetConfig.name());
            sheetMeta.setDtoClass(sheetConfig.dto());
            sheetMeta.setTemplate(sheetConfig.template());
            
            // ì‹œì‘ ì…€ íŒŒì‹±
            CellReference startRef = new CellReference(sheetConfig.startCell());
            sheetMeta.setStartCell(startRef);
            
            // ë°ì´í„° ì‹œì‘ ì…€ íŒŒì‹± (ì§€ì •ëœ ê²½ìš°)
            if (!sheetConfig.dataStartCell().isEmpty()) {
                sheetMeta.setDataStartCell(new CellReference(sheetConfig.dataStartCell()));
            } else {
                // ê¸°ë³¸ê°’: í—¤ë” ë‹¤ìŒ í–‰
                sheetMeta.setDataStartCell(new CellReference(
                    startRef.getRow() + 1, startRef.getCol()));
            }
            
            // 3. ì»¬ëŸ¼ ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
            extractColumns(sheetMeta);
            
            meta.getSheets().add(sheetMeta);
        }
        
        return meta;
    }
    
    private static void extractColumns(SheetMeta sheetMeta) {
        Class<?> dtoClass = sheetMeta.getDtoClass();
        Map<Integer, ColumnMeta> columnMap = new TreeMap<>(); // ìˆœì„œ ë³´ì¥
        
        for (Field field : dtoClass.getDeclaredFields()) {
            if (field.isAnnotationPresent(ExcelColumn.class)) {
                ExcelColumn colAnno = field.getAnnotation(ExcelColumn.class);
                
                ColumnMeta colMeta = new ColumnMeta();
                colMeta.setField(field);
                colMeta.setOrder(colAnno.order());
                colMeta.setHeader(colAnno.header());
                colMeta.setHeaderKey(colAnno.headerKey());
                colMeta.setWidth(colAnno.width());
                colMeta.setHeaderStyle(colAnno.headerStyle());
                colMeta.setDataStyle(colAnno.dataStyle());
                
                columnMap.put(colAnno.order(), colMeta);
            }
        }
        
        // ì»¬ëŸ¼ ìˆœì„œëŒ€ë¡œ ì¶”ê°€
        sheetMeta.getColumns().addAll(columnMap.values());
    }
}
```

ë©”íƒ€ë°ì´í„° ì¶”ì¶œê¸°ëŠ” `@ExcelDocument` ì• ë…¸í…Œì´ì…˜ì´ ì ìš©ëœ í´ë˜ìŠ¤ì™€ ê´€ë ¨ DTO í´ë˜ìŠ¤ì—ì„œ ì—‘ì…€ ë¬¸ì„œ ìƒì„±ì— í•„ìš”í•œ ëª¨ë“  ì •ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.

## 4. Streaming Engine â€“ ë©”ëª¨ë¦¬ í•œê³„ ê·¹ë³µ

ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ë¥¼ ìœ„í•´ Apache POIì˜ SXSSF(Streaming XML SpreadSheet Format) APIë¥¼ í™œìš©í•©ë‹ˆë‹¤.

```java
/**
 * ì—‘ì…€ ì—”ì§„ ì¸í„°í˜ì´ìŠ¤
 */
public interface ExcelEngine {
    void export(ExcelMeta meta, 
                Map<String, List<?>> dataMap, 
                List<ValueConverter> converters,
                I18nResolver i18nResolver,
                Locale locale,
                OutputStream os) throws IOException;
}

/**
 * ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ ì—‘ì…€ ì—”ì§„
 */
public class StreamingExcelEngine implements ExcelEngine {

    private final StyleManager styleManager;
    private final int windowSize;
    
    public StreamingExcelEngine(StyleManager styleManager,
                               @Value("${excel.streaming.window-size:100}") int windowSize) {
        this.styleManager = styleManager;
        this.windowSize = windowSize;
    }

    @Override
    public void export(ExcelMeta meta,
                       Map<String, List<?>> dataMap,
                       List<ValueConverter> converters,
                       I18nResolver i18nResolver,
                       Locale locale,
                       OutputStream os) throws IOException {

        // SXSSF ì›Œí¬ë¶ ìƒì„± (windowSize í–‰ë§Œ ë©”ëª¨ë¦¬ì— ìœ ì§€)
        SXSSFWorkbook wb = new SXSSFWorkbook(windowSize);
        
        try {
            // 1. í…œí”Œë¦¿ ì ìš© (ë¬¸ì„œ ì „ì²´ í…œí”Œë¦¿ì´ ìˆëŠ” ê²½ìš°)
            if (!meta.getTemplate().isEmpty()) {
                applyDocumentTemplate(wb, meta.getTemplate());
            }
            
            // 2. ê° ì‹œíŠ¸ ì²˜ë¦¬
            for (SheetMeta sheetMeta : meta.getSheets()) {
                String sheetName = sheetMeta.getName();
                List<?> data = dataMap.get(sheetName);
                
                if (data == null) {
                    throw new ExcelException("No data for sheet: " + sheetName);
                }
                
                // 2.1. ì‹œíŠ¸ ìƒì„±
                Sheet sheet = wb.createSheet(sheetName);
                
                // 2.2. ì‹œíŠ¸ë³„ í…œí”Œë¦¿ ì ìš© (ìˆëŠ” ê²½ìš°)
                if (!sheetMeta.getTemplate().isEmpty()) {
                    applySheetTemplate(sheet, sheetMeta.getTemplate());
                }
                
                // 2.3. í—¤ë” ì‘ì„±
                writeHeader(sheet, sheetMeta, i18nResolver, locale);
                
                // 2.4. ë°ì´í„° í–‰ ì‘ì„±
                writeData(sheet, sheetMeta, data, converters);
                
                // 2.5. ì»¬ëŸ¼ ë„ˆë¹„ ì¡°ì •
                adjustColumnWidths(sheet, sheetMeta);
            }
            
            // 3. íŒŒì¼ ì“°ê¸°
            wb.write(os);
        } finally {
            // 4. ì„ì‹œ íŒŒì¼ ì •ë¦¬
            wb.dispose();
        }
    }

    private void applyDocumentTemplate(SXSSFWorkbook wb, String templatePath) {
        try (InputStream is = getClass().getResourceAsStream(templatePath)) {
            if (is == null) {
                throw new ExcelException("Template not found: " + templatePath);
            }
            
            XSSFWorkbook template = new XSSFWorkbook(is);
            
            // í…œí”Œë¦¿ ìŠ¤íƒ€ì¼ ë° êµ¬ì¡° ë³µì‚¬
            // (ì—¬ê¸°ì„œëŠ” ê°„ëµí™”ë¥¼ ìœ„í•´ ë³µì¡í•œ í…œí”Œë¦¿ ë³µì‚¬ ë¡œì§ ìƒëµ)
        } catch (IOException e) {
            throw new ExcelException("Failed to apply template", e);
        }
    }
    
    private void applySheetTemplate(Sheet sheet, String templatePath) {
        // ì‹œíŠ¸ë³„ í…œí”Œë¦¿ ì ìš© ë¡œì§
    }

    private void writeHeader(Sheet sheet, SheetMeta sheetMeta, I18nResolver i18nResolver, Locale locale) {
        int startRow = sheetMeta.getStartRow();
        int startCol = sheetMeta.getStartCol();
        
        // í—¤ë” í–‰ ìƒì„±
        Row headerRow = sheet.createRow(startRow);
        
        // ê° ì»¬ëŸ¼ í—¤ë” ìƒì„±
        for (ColumnMeta colMeta : sheetMeta.getColumns()) {
            Cell cell = headerRow.createCell(startCol + colMeta.getOrder());
            
            // í—¤ë” í…ìŠ¤íŠ¸ ê²°ì • (ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©)
            String headerText;
            if (!colMeta.getHeaderKey().isEmpty()) {
                headerText = i18nResolver.getMessage(colMeta.getHeaderKey(), locale);
            } else {
                headerText = colMeta.getHeader();
            }
            
            cell.setCellValue(headerText);
            
            // í—¤ë” ìŠ¤íƒ€ì¼ ì ìš©
            cell.setCellStyle(styleManager.getHeaderStyle(colMeta.getHeaderStyle(), sheet.getWorkbook()));
        }
    }
    
    private void writeData(Sheet sheet, SheetMeta sheetMeta, List<?> data, List<ValueConverter> converters) {
        int rowIdx = sheetMeta.getDataStartCell().getRow();
        int startCol = sheetMeta.getStartCol();
        
        // ê° ë°ì´í„° í–‰ ì²˜ë¦¬
        for (Object dto : data) {
            Row row = sheet.createRow(rowIdx++);
            
            // ê° ì»¬ëŸ¼ ë°ì´í„° ì‘ì„±
            for (ColumnMeta colMeta : sheetMeta.getColumns()) {
                Cell cell = row.createCell(startCol + colMeta.getOrder());
                
                // í•„ë“œ ê°’ ì¶”ì¶œ
                Object value = getFieldValue(dto, colMeta.getField());
                
                // ì»¨ë²„í„° ì ìš©
                value = applyConverters(value, colMeta.getField(), converters);
                
                // ì…€ì— ê°’ ì„¤ì •
                setCellValue(cell, value);
                
                // ë°ì´í„° ìŠ¤íƒ€ì¼ ì ìš©
                cell.setCellStyle(styleManager.getDataStyle(colMeta.getDataStyle(), sheet.getWorkbook()));
            }
        }
    }
    
    private Object getFieldValue(Object dto, Field field) {
        try {
            field.setAccessible(true);
            return field.get(dto);
        } catch (IllegalAccessException e) {
            throw new ExcelException("Failed to access field: " + field.getName(), e);
        }
    }
    
    private Object applyConverters(Object value, Field field, List<ValueConverter> converters) {
        if (value == null) return null;
        
        // ì ìš© ê°€ëŠ¥í•œ ëª¨ë“  ì»¨ë²„í„° ì ìš©
        for (ValueConverter converter : converters) {
            if (converter.supports(field)) {
                value = converter.convert(value);
            }
        }
        
        return value;
    }
    
    private void setCellValue(Cell cell, Object value) {
        if (value == null) {
            cell.setCellValue("");
            return;
        }
        
        // íƒ€ì…ì— ë”°ë¥¸ ì…€ ê°’ ì„¤ì •
        if (value instanceof Number) {
            cell.setCellValue(((Number) value).doubleValue());
        } else if (value instanceof Boolean) {
            cell.setCellValue((Boolean) value);
        } else if (value instanceof LocalDate) {
            cell.setCellValue(Date.from(((LocalDate) value).atStartOfDay(ZoneId.systemDefault()).toInstant()));
        } else if (value instanceof LocalDateTime) {
            cell.setCellValue(Date.from(((LocalDateTime) value).atZone(ZoneId.systemDefault()).toInstant()));
        } else {
            cell.setCellValue(value.toString());
        }
    }
    
    private void adjustColumnWidths(Sheet sheet, SheetMeta sheetMeta) {
        int startCol = sheetMeta.getStartCol();
        
        // ê° ì»¬ëŸ¼ ë„ˆë¹„ ì„¤ì •
        for (ColumnMeta colMeta : sheetMeta.getColumns()) {
            int colIndex = startCol + colMeta.getOrder();
            int width = colMeta.getWidth();
            
            if (width > 0) {
                // ë„ˆë¹„ê°€ ì§€ì •ëœ ê²½ìš° í•´ë‹¹ ë„ˆë¹„ë¡œ ì„¤ì •
                sheet.setColumnWidth(colIndex, width * 256); // POI ë‹¨ìœ„ ë³€í™˜
            } else {
                // ìë™ ë„ˆë¹„ ì¡°ì •
                sheet.autoSizeColumn(colIndex);
            }
        }
    }
}

/**
 * ì¸ë©”ëª¨ë¦¬ ë°©ì‹ ì—‘ì…€ ì—”ì§„
 */
public class InMemoryExcelEngine implements ExcelEngine {
    
    private final StyleManager styleManager;
    
    public InMemoryExcelEngine(StyleManager styleManager) {
        this.styleManager = styleManager;
    }
    
    @Override
    public void export(ExcelMeta meta, 
                      Map<String, List<?>> dataMap, 
                      List<ValueConverter> converters,
                      I18nResolver i18nResolver,
                      Locale locale, 
                      OutputStream os) throws IOException {
        
        // ì¼ë°˜ XSSFWorkbook ì‚¬ìš© (ëª¨ë“  ë°ì´í„°ë¥¼ ë©”ëª¨ë¦¬ì— ìœ ì§€)
        XSSFWorkbook wb = new XSSFWorkbook();
        
        try {
            // êµ¬í˜„ ë¡œì§ì€ StreamingExcelEngineê³¼ ìœ ì‚¬í•˜ë‚˜,
            // SXSSFWorkbook íŠ¹í™” ê¸°ëŠ¥ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
            
            // íŒŒì¼ ì“°ê¸°
            wb.write(os);
        } finally {
            wb.close();
        }
    }
    
    // ë‚˜ë¨¸ì§€ ë©”ì„œë“œë“¤ì€ StreamingExcelEngineê³¼ ìœ ì‚¬
}
```

ì´ ìŠ¤íŠ¸ë¦¬ë° ì—”ì§„ì€ ë‹¤ìŒê³¼ ê°™ì€ íŠ¹ì§•ì„ ê°€ì§‘ë‹ˆë‹¤
- `new SXSSFWorkbook(windowSize)` â†’ ë©”ëª¨ë¦¬ ìƒì— ìµœëŒ€ windowSize í–‰ë§Œ ìœ ì§€
- `dispose()` í˜¸ì¶œë¡œ ë‚´ë¶€ ì„ì‹œíŒŒì¼ ìë™ ì‚­ì œ
- í…œí”Œë¦¿ ì ìš©, í—¤ë” ì‘ì„±, ë°ì´í„° ì²˜ë¦¬, ìŠ¤íƒ€ì¼ë§ ë“± ëª¨ë“  ê¸°ëŠ¥ ì§€ì›
- ìµœëŒ€ 100ë§Œ í–‰ ë°ì´í„°ë„ ì„œë¹„ìŠ¤ ë©”ëª¨ë¦¬ì— ë¶€ë‹´ ì—†ì´ ì²˜ë¦¬ ê°€ëŠ¥

## 5. Plugin ì•„í‚¤í…ì²˜

### 5.1. ValueConverter

```java
/**
 * í•„ë“œ ê°’ ë³€í™˜ê¸° ì¸í„°í˜ì´ìŠ¤
 */
public interface ValueConverter {
    /**
     * ì´ ë³€í™˜ê¸°ê°€ ì§€ì›í•˜ëŠ” í•„ë“œì¸ì§€ í™•ì¸
     */
    boolean supports(Field field);
    
    /**
     * ì›ë³¸ ê°’ì„ ë³€í™˜í•˜ì—¬ ë°˜í™˜
     */
    Object convert(Object raw);
}

/**
 * ë“±ê¸‰ ì½”ë“œë¥¼ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜í•˜ëŠ” ë³€í™˜ê¸° êµ¬í˜„ì²´
 */
@Component
public class GradeConverter implements ValueConverter {
    @Override
    public boolean supports(Field field) {
        // 'grade' í•„ë“œì—ë§Œ ì ìš©
        return field.getName().equals("grade");
    }
    
    @Override
    public Object convert(Object raw) {
        if (raw == null) return null;
        
        // ë“±ê¸‰ ì½”ë“œë¥¼ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜
        return switch(raw.toString()) {
            case "G" -> "Gold";
            case "S" -> "Silver";
            case "B" -> "Bronze";
            default -> raw;
        };
    }
}

/**
 * ë‚ ì§œ í˜•ì‹ì„ ë³€í™˜í•˜ëŠ” ë³€í™˜ê¸°
 */
@Component
public class DateFormatConverter implements ValueConverter {
    private final DateTimeFormatter formatter;
    
    public DateFormatConverter(@Value("${excel.date.format:yyyy-MM-dd}") String pattern) {
        this.formatter = DateTimeFormatter.ofPattern(pattern);
    }
    
    @Override
    public boolean supports(Field field) {
        // LocalDate íƒ€ì… í•„ë“œì—ë§Œ ì ìš©
        return field.getType() == LocalDate.class;
    }
    
    @Override
    public Object convert(Object raw) {
        if (raw == null) return null;
        if (raw instanceof LocalDate) {
            return formatter.format((LocalDate) raw);
        }
        return raw;
    }
}

/**
 * í•„ë“œ ì• ë…¸í…Œì´ì…˜ìœ¼ë¡œ ë³€í™˜ê¸°ë¥¼ ì •ì˜í•˜ëŠ” ë°©ì‹
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ConvertValue {
    /**
     * ì‚¬ìš©í•  ë³€í™˜ê¸° í´ë˜ìŠ¤
     */
    Class<? extends ValueConverter> converter();
    
    /**
     * ë³€í™˜ê¸°ì— ì „ë‹¬í•  ì†ì„±
     */
    String[] args() default {};
}

/**
 * ì• ë…¸í…Œì´ì…˜ ê¸°ë°˜ ê°’ ë³€í™˜ê¸°
 */
public class AnnotationValueConverter implements ValueConverter {
    private final ApplicationContext context;
    
    public AnnotationValueConverter(ApplicationContext context) {
        this.context = context;
    }
    
    @Override
    public boolean supports(Field field) {
        return field.isAnnotationPresent(ConvertValue.class);
    }
    
    @Override
    public Object convert(Object raw) {
        if (raw == null) return null;
        
        try {
            Field field = getFieldFromContext(); // í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ í•„ë“œ ê°€ì ¸ì˜¤ê¸°
            ConvertValue anno = field.getAnnotation(ConvertValue.class);
            
            // ë¹ˆì—ì„œ ë³€í™˜ê¸° ê°€ì ¸ì˜¤ê¸° ë˜ëŠ” ìƒì„±
            ValueConverter delegateConverter = getConverter(anno.converter());
            
            return delegateConverter.convert(raw);
        } catch (Exception e) {
            throw new ExcelException("Failed to convert value", e);
        }
    }
    
    private ValueConverter getConverter(Class<? extends ValueConverter> converterClass) {
        try {
            // ë¹ˆìœ¼ë¡œ ë“±ë¡ëœ ê²½ìš°
            return context.getBean(converterClass);
        } catch (NoSuchBeanDefinitionException e) {
            // ë“±ë¡ë˜ì§€ ì•Šì€ ê²½ìš° ìƒˆë¡œ ìƒì„±
            try {
                return converterClass.getDeclaredConstructor().newInstance();
            } catch (Exception ex) {
                throw new ExcelException("Failed to create converter: " + converterClass.getName(), ex);
            }
        }
    }
    
    private Field getFieldFromContext() {
        // í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ í•„ë“œ ì •ë³´ë¥¼ ThreadLocal ë“±ì„ í†µí•´ ê°€ì ¸ì˜¤ëŠ” ë¡œì§
        // (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ í•„ìš”)
        return ExcelContextHolder.getCurrentField();
    }
}
```

### 5.2. Validator

```java
/**
 * í•„ìˆ˜ê°’ ê²€ì¦ ì• ë…¸í…Œì´ì…˜
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface NotEmpty { 
    /**
     * ê²€ì¦ ì‹¤íŒ¨ ì‹œ ë©”ì‹œì§€
     */
    String message() default "í•„ìˆ˜ ê°’ì…ë‹ˆë‹¤."; 
}

/**
 * ìµœëŒ€ ê¸¸ì´ ê²€ì¦ ì• ë…¸í…Œì´ì…˜
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MaxLength {
    /**
     * ìµœëŒ€ í—ˆìš© ê¸¸ì´
     */
    int value();
    
    /**
     * ê²€ì¦ ì‹¤íŒ¨ ì‹œ ë©”ì‹œì§€
     */
    String message() default "ìµœëŒ€ {value}ìê¹Œì§€ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.";
}

/**
 * ë°ì´í„° ê²€ì¦ê¸° ì¸í„°í˜ì´ìŠ¤
 */
public interface Validator {
    /**
     * DTO ê°ì²´ ê²€ì¦
     * @throws ValidationException ê²€ì¦ ì‹¤íŒ¨ ì‹œ
     */
    void validate(Object dto) throws ValidationException;
}

/**
 * ì• ë…¸í…Œì´ì…˜ ê¸°ë°˜ ê²€ì¦ê¸° êµ¬í˜„ì²´
 */
public class AnnotationValidator implements Validator {
    @Override
    public void validate(Object dto) {
        if (dto == null) {
            throw new ValidationException("DTO cannot be null");
        }
        
        // ëª¨ë“  í•„ë“œì— ëŒ€í•´ ê²€ì¦
        for (Field field : dto.getClass().getDeclaredFields()) {
            field.setAccessible(true);
            
            try {
                Object value = field.get(dto);
                
                // @NotEmpty ê²€ì¦
                if (field.isAnnotationPresent(NotEmpty.class)) {
                    validateNotEmpty(field, value);
                }
                
                // @MaxLength ê²€ì¦
                if (field.isAnnotationPresent(MaxLength.class)) {
                    validateMaxLength(field, value);
                }
                
                // ì¶”ê°€ ê²€ì¦ ë¡œì§...
            } catch (IllegalAccessException e) {
                throw new ValidationException("Cannot access field: " + field.getName(), e);
            }
        }
    }
    
    private void validateNotEmpty(Field field, Object value) {
        NotEmpty anno = field.getAnnotation(NotEmpty.class);
        
        if (value == null || value.toString().isBlank()) {
            String fieldName = field.getName();
            String message = anno.message();
            
            throw new ValidationException(fieldName + ": " + message);
        }
    }
    
    private void validateMaxLength(Field field, Object value) {
        if (value == null) return;
        
        MaxLength anno = field.getAnnotation(MaxLength.class);
        int maxLength = anno.value();
        String strValue = value.toString();
        
        if (strValue.length() > maxLength) {
            String fieldName = field.getName();
            String message = anno.message().replace("{value}", String.valueOf(maxLength));
            
            throw new ValidationException(fieldName + ": " + message);
        }
    }
}

/**
 * ê²€ì¦ ì˜ˆì™¸
 */
public class ValidationException extends RuntimeException {
    public ValidationException(String message) {
        super(message);
    }
    
    public ValidationException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### 5.3. Formatter

```java
/**
 * ì…€ í¬ë§·í„° ì¸í„°í˜ì´ìŠ¤
 */
public interface CellFormatter {
    /**
     * ì´ í¬ë§·í„°ê°€ ì§€ì›í•˜ëŠ” í•„ë“œì¸ì§€ í™•ì¸
     */
    boolean supports(Field field);
    
    /**
     * POI ì…€ ë°ì´í„° í¬ë§· ì ìš©
     */
    void applyFormat(Cell cell, Object value);
}

/**
 * ì „í™”ë²ˆí˜¸ í¬ë§·í„° êµ¬í˜„ì²´
 */
@Component
public class PhoneNumberFormatter implements CellFormatter {
    private final DataFormat format;
    
    public PhoneNumberFormatter(Workbook workbook) {
        this.format = workbook.createDataFormat();
    }
    
    @Override
    public boolean supports(Field field) {
        return field.isAnnotationPresent(PhoneNumber.class) || 
               field.getName().contains("phone") ||
               field.getName().contains("tel");
    }
    
    @Override
    public void applyFormat(Cell cell, Object value) {
        if (value == null) return;
        
        CellStyle style = cell.getCellStyle();
        // ì „í™”ë²ˆí˜¸ í¬ë§· ì ìš© (###-####-####)
        short formatIndex = format.getFormat("###-####-####");
        style.setDataFormat(formatIndex);
        cell.setCellStyle(style);
    }
}

/**
 * í¬ë§·í„° ì• ë…¸í…Œì´ì…˜
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Format {
    /**
     * í¬ë§· íŒ¨í„´
     * (ì˜ˆ: "#,##0.00", "yyyy-mm-dd" ë“±)
     */
    String pattern();
}

/**
 * ì „í™”ë²ˆí˜¸ ì• ë…¸í…Œì´ì…˜
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PhoneNumber {}

/**
 * ìˆ«ì í¬ë§· ì• ë…¸í…Œì´ì…˜
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface NumberFormat {
    /**
     * í¬ë§· íŒ¨í„´ (ì˜ˆ: "#,##0", "#,##0.00" ë“±)
     */
    String pattern();
    
    /**
     * ì†Œìˆ˜ì  ìë¦¿ìˆ˜
     */
    int decimals() default 2;
    
    /**
     * ì²œ ë‹¨ìœ„ êµ¬ë¶„ì ì‚¬ìš© ì—¬ë¶€
     */
    boolean useThousandSeparator() default true;
}

/**
 * ìˆ«ì í¬ë§·í„° êµ¬í˜„ì²´
 */
@Component
public class NumberFormatter implements CellFormatter {
    private final DataFormat dataFormat;
    
    public NumberFormatter(Workbook workbook) {
        this.dataFormat = workbook.createDataFormat();
    }
    
    @Override
    public boolean supports(Field field) {
        return field.isAnnotationPresent(NumberFormat.class) ||
               Number.class.isAssignableFrom(field.getType()) ||
               field.getType() == BigDecimal.class;
    }
    
    @Override
    public void applyFormat(Cell cell, Object value) {
        if (value == null) return;
        
        CellStyle style = cell.getCellStyle();
        String pattern;
        
        // ì• ë…¸í…Œì´ì…˜ì´ ìˆëŠ” ê²½ìš° í•´ë‹¹ íŒ¨í„´ ì‚¬ìš©
        Field field = ExcelContextHolder.getCurrentField();
        if (field != null && field.isAnnotationPresent(NumberFormat.class)) {
            NumberFormat anno = field.getAnnotation(NumberFormat.class);
            if (!anno.pattern().isEmpty()) {
                pattern = anno.pattern();
            } else {
                // ê¸°ë³¸ íŒ¨í„´ ìƒì„±
                pattern = anno.useThousandSeparator() ? "#,##0" : "0";
                if (anno.decimals() > 0) {
                    pattern += ".";
                    pattern += "0".repeat(anno.decimals());
                }
            }
        } else {
            // ê¸°ë³¸ ìˆ«ì í¬ë§·
            pattern = "#,##0.00";
        }
        
        // ìŠ¤íƒ€ì¼ì— í¬ë§· ì ìš©
        short formatIndex = dataFormat.getFormat(pattern);
        style.setDataFormat(formatIndex);
        cell.setCellStyle(style);
    }
}

/**
 * ë‚ ì§œ í¬ë§· ì• ë…¸í…Œì´ì…˜
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DateFormat {
    /**
     * ë‚ ì§œ í¬ë§· íŒ¨í„´ (ì˜ˆ: "yyyy-MM-dd", "yyyy/MM/dd" ë“±)
     */
    String pattern() default "yyyy-MM-dd";
}

/**
 * ë‚ ì§œ í¬ë§·í„° êµ¬í˜„ì²´
 */
@Component
public class DateFormatter implements CellFormatter {
    private final DataFormat dataFormat;
    
    public DateFormatter(Workbook workbook) {
        this.dataFormat = workbook.createDataFormat();
    }
    
    @Override
    public boolean supports(Field field) {
        return field.isAnnotationPresent(DateFormat.class) ||
               field.getType() == Date.class ||
               field.getType() == LocalDate.class ||
               field.getType() == LocalDateTime.class;
    }
    
    @Override
    public void applyFormat(Cell cell, Object value) {
        if (value == null) return;
        
        CellStyle style = cell.getCellStyle();
        String pattern;
        
        // ì• ë…¸í…Œì´ì…˜ì´ ìˆëŠ” ê²½ìš° í•´ë‹¹ íŒ¨í„´ ì‚¬ìš©
        Field field = ExcelContextHolder.getCurrentField();
        if (field != null && field.isAnnotationPresent(DateFormat.class)) {
            DateFormat anno = field.getAnnotation(DateFormat.class);
            pattern = anno.pattern();
        } else {
            // íƒ€ì…ì— ë”°ë¥¸ ê¸°ë³¸ í¬ë§· ì ìš©
            if (field != null && field.getType() == LocalDateTime.class) {
                pattern = "yyyy-MM-dd HH:mm:ss";
            } else {
                pattern = "yyyy-MM-dd";
            }
        }
        
        // ìŠ¤íƒ€ì¼ì— í¬ë§· ì ìš©
        short formatIndex = dataFormat.getFormat(pattern);
        style.setDataFormat(formatIndex);
        cell.setCellStyle(style);
    }
}

/**
 * í¬ë§·í„° ì»´í¬ì§€íŠ¸ íŒ¨í„´ êµ¬í˜„
 */
public class CompositeCellFormatter implements CellFormatter {
    private final List<CellFormatter> formatters;
    
    public CompositeCellFormatter(List<CellFormatter> formatters) {
        this.formatters = formatters;
    }
    
    @Override
    public boolean supports(Field field) {
        // ìµœì†Œ í•˜ë‚˜ì˜ í¬ë§·í„°ê°€ ì§€ì›í•˜ë©´ true
        return formatters.stream().anyMatch(formatter -> formatter.supports(field));
    }
    
    @Override
    public void applyFormat(Cell cell, Object value) {
        // ì§€ì›í•˜ëŠ” ì²« ë²ˆì§¸ í¬ë§·í„° ì ìš©
        for (CellFormatter formatter : formatters) {
            Field field = ExcelContextHolder.getCurrentField();
            if (field != null && formatter.supports(field)) {
                formatter.applyFormat(cell, value);
                break;
            }
        }
    }
}

/**
 * í¬ë§·í„° ë“±ë¡ ë§¤ë‹ˆì €
 */
@Component
public class FormatterManager {
    private final Map<String, CellFormatter> formatterMap = new HashMap<>();
    private CompositeCellFormatter compositeCellFormatter;
    
    @Autowired
    public FormatterManager(ApplicationContext context, Workbook workbook) {
        // ê¸°ë³¸ í¬ë§·í„° ë“±ë¡
        registerFormatter("phone", new PhoneNumberFormatter(workbook));
        registerFormatter("number", new NumberFormatter(workbook));
        registerFormatter("date", new DateFormatter(workbook));
        
        // ë¹ˆìœ¼ë¡œ ë“±ë¡ëœ í¬ë§·í„°ë„ ìë™ ë“±ë¡
        context.getBeansOfType(CellFormatter.class).values()
               .forEach(formatter -> registerFormatter(
                   formatter.getClass().getSimpleName(), formatter));
               
        // í•©ì„± í¬ë§·í„° ìƒì„±
        List<CellFormatter> allFormatters = new ArrayList<>(formatterMap.values());
        this.compositeCellFormatter = new CompositeCellFormatter(allFormatters);
    }
    
    public void registerFormatter(String name, CellFormatter formatter) {
        formatterMap.put(name, formatter);
    }
    
    public CellFormatter getFormatter(String name) {
        return formatterMap.get(name);
    }
    
    public CellFormatter getCompositeFormatter() {
        return compositeCellFormatter;
    }
}
```

### 5.4. ë‹¤ì´ë‚˜ë¯¹ í”ŒëŸ¬ê·¸ì¸ ë¼ì´í”„ì‚¬ì´í´

í”ŒëŸ¬ê·¸ì¸ë“¤ì€ ë‹¨ìˆœíˆ ìŠ¤í”„ë§ ë¹ˆìœ¼ë¡œ ë“±ë¡ë˜ëŠ” ê²ƒì„ ë„˜ì–´, ë™ì ì¸ ë¼ì´í”„ì‚¬ì´í´ì„ ê°€ì§‘ë‹ˆë‹¤. ì´ëŠ” ëŸ°íƒ€ì„ì— ìƒˆë¡œìš´ í”ŒëŸ¬ê·¸ì¸ì„ ë“±ë¡í•˜ê±°ë‚˜ ê¸°ì¡´ í”ŒëŸ¬ê·¸ì¸ì„ êµì²´í•˜ëŠ” ê²ƒì„ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.

```java
/**
 * í”ŒëŸ¬ê·¸ì¸ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬ì
 */
@Component
public class PluginLifecycleManager {
    private final List<ValueConverter> valueConverters = new ArrayList<>();
    private final List<Validator> validators = new ArrayList<>();
    private final FormatterManager formatterManager;
    
    @Autowired
    public PluginLifecycleManager(
            List<ValueConverter> converters,
            List<Validator> validators,
            FormatterManager formatterManager) {
        // ìŠ¤í”„ë§ ë¹ˆìœ¼ë¡œ ë“±ë¡ëœ ëª¨ë“  í”ŒëŸ¬ê·¸ì¸ ì´ˆê¸°í™”
        this.valueConverters.addAll(converters);
        this.validators.addAll(validators);
        this.formatterManager = formatterManager;
    }
    
    /**
     * ëª¨ë“  ê°’ ë³€í™˜ê¸° ì¡°íšŒ
     */
    public List<ValueConverter> getAllValueConverters() {
        return Collections.unmodifiableList(valueConverters);
    }
    
    /**
     * ëª¨ë“  ê²€ì¦ê¸° ì¡°íšŒ
     */
    public List<Validator> getAllValidators() {
        return Collections.unmodifiableList(validators);
    }
    
    /**
     * ëŸ°íƒ€ì„ì— ìƒˆ ë³€í™˜ê¸° ë“±ë¡
     */
    public void registerValueConverter(ValueConverter converter) {
        valueConverters.add(converter);
    }
    
    /**
     * ëŸ°íƒ€ì„ì— ìƒˆ ê²€ì¦ê¸° ë“±ë¡
     */
    public void registerValidator(Validator validator) {
        validators.add(validator);
    }
    
    /**
     * íŠ¹ì • ë³€í™˜ê¸° ë¹„í™œì„±í™”
     */
    public void disableValueConverter(Class<? extends ValueConverter> converterClass) {
        valueConverters.removeIf(c -> c.getClass().equals(converterClass));
    }
    
    /**
     * íŠ¹ì • ê²€ì¦ê¸° ë¹„í™œì„±í™”
     */
    public void disableValidator(Class<? extends Validator> validatorClass) {
        validators.removeIf(v -> v.getClass().equals(validatorClass));
    }
    
    /**
     * í”ŒëŸ¬ê·¸ì¸ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± (íŒ©í† ë¦¬ ë©”ì„œë“œ)
     */
    public <T> T createPlugin(Class<T> pluginClass, Object... args) {
        try {
            // ìƒì„±ì ì°¾ê¸°
            Constructor<?>[] constructors = pluginClass.getDeclaredConstructors();
            Constructor<?> constructor = null;
            
            for (Constructor<?> c : constructors) {
                if (c.getParameterCount() == args.length) {
                    constructor = c;
                    break;
                }
            }
            
            if (constructor == null) {
                throw new ExcelException("No suitable constructor found for " + pluginClass.getName());
            }
            
            constructor.setAccessible(true);
            @SuppressWarnings("unchecked")
            T instance = (T) constructor.newInstance(args);
            return instance;
        } catch (Exception e) {
            throw new ExcelException("Failed to create plugin: " + pluginClass.getName(), e);
        }
    }
}
```

### 5.5. JSON ê¸°ë°˜ í”ŒëŸ¬ê·¸ì¸ ì„¤ì •

ë³µì¡í•œ í”ŒëŸ¬ê·¸ì¸ êµ¬ì„±ì„ ì‰½ê²Œ ì„¤ì •í•˜ê¸° ìœ„í•´ JSON ê¸°ë°˜ ì„¤ì • ì§€ì›:

```java
/**
 * JSON ê¸°ë°˜ í”ŒëŸ¬ê·¸ì¸ ì„¤ì • ë¡œë”
 */
@Component
public class PluginConfigLoader {
    private final ObjectMapper objectMapper;
    private final PluginLifecycleManager pluginManager;
    
    public PluginConfigLoader(
            ObjectMapper objectMapper,
            PluginLifecycleManager pluginManager) {
        this.objectMapper = objectMapper;
        this.pluginManager = pluginManager;
    }
    
    /**
     * JSON ì„¤ì • íŒŒì¼ì—ì„œ í”ŒëŸ¬ê·¸ì¸ êµ¬ì„± ë¡œë“œ
     */
    public void loadConfig(Resource configResource) throws IOException {
        JsonNode config = objectMapper.readTree(configResource.getInputStream());
        
        // ë³€í™˜ê¸° ì„¤ì • ì²˜ë¦¬
        if (config.has("converters")) {
            JsonNode convertersNode = config.get("converters");
            for (JsonNode node : convertersNode) {
                loadConverter(node);
            }
        }
        
        // ê²€ì¦ê¸° ì„¤ì • ì²˜ë¦¬
        if (config.has("validators")) {
            JsonNode validatorsNode = config.get("validators");
            for (JsonNode node : validatorsNode) {
                loadValidator(node);
            }
        }
        
        // í¬ë§·í„° ì„¤ì • ì²˜ë¦¬
        if (config.has("formatters")) {
            JsonNode formattersNode = config.get("formatters");
            for (JsonNode node : formattersNode) {
                loadFormatter(node);
            }
        }
    }
    
    private void loadConverter(JsonNode node) {
        try {
            String className = node.get("class").asText();
            Class<?> converterClass = Class.forName(className);
            
            // íŒŒë¼ë¯¸í„° ì²˜ë¦¬
            List<Object> params = new ArrayList<>();
            if (node.has("params")) {
                JsonNode paramsNode = node.get("params");
                for (JsonNode paramNode : paramsNode) {
                    params.add(objectMapper.treeToValue(paramNode, Object.class));
                }
            }
            
            // í”ŒëŸ¬ê·¸ì¸ ìƒì„± ë° ë“±ë¡
            ValueConverter converter = pluginManager.createPlugin(
                (Class<ValueConverter>) converterClass, 
                params.toArray()
            );
            pluginManager.registerValueConverter(converter);
        } catch (Exception e) {
            throw new ExcelException("Failed to load converter from JSON config", e);
        }
    }
    
    private void loadValidator(JsonNode node) {
        // ê²€ì¦ê¸° ë¡œë”© ë¡œì§ (ë³€í™˜ê¸°ì™€ ìœ ì‚¬)
    }
    
    private void loadFormatter(JsonNode node) {
        // í¬ë§·í„° ë¡œë”© ë¡œì§ (ë³€í™˜ê¸°ì™€ ìœ ì‚¬)
    }
}
```

### 5.6. í”ŒëŸ¬ê·¸ì¸ ì‚¬ìš© ì˜ˆì‹œ

ë‹¤ìŒì€ ë‹¤ì–‘í•œ í”ŒëŸ¬ê·¸ì¸ì„ í™œìš©í•˜ëŠ” ì¢…í•©ì ì¸ ì˜ˆì‹œì…ë‹ˆë‹¤

```java
@RestController
@RequiredArgsConstructor
public class AdvancedReportController {
    private final ExcelBuilder excelBuilder;
    private final PluginLifecycleManager pluginManager;
    private final FormatterManager formatterManager;
    
    @GetMapping("/report/advanced")
    public void downloadAdvancedReport(HttpServletResponse response, Locale locale) throws IOException {
        // ë°ì´í„° ì¤€ë¹„
        List<AdvancedReportDto> data = prepareReportData();
        
        // ë™ì  í•„ë“œë³„ ì „ìš© ë³€í™˜ê¸° ìƒì„±
        ValueConverter customConverter = new ValueConverter() {
            @Override
            public boolean supports(Field field) {
                return field.getName().equals("status");
            }
            
            @Override
            public Object convert(Object raw) {
                if (raw == null) return null;
                String status = raw.toString();
                // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ë”°ë¥¸ ë™ì  ë³€í™˜
                if (status.startsWith("P")) {
                    return "ì§„í–‰ì¤‘ (" + status + ")";
                } else if (status.startsWith("C")) {
                    return "ì™„ë£Œ (" + status + ")";
                }
                return raw;
            }
        };
        
        // ì‘ë‹µ ì„¤ì •
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setHeader("Content-Disposition", "attachment; filename=advanced_report.xlsx");
        
        // ì‹œìŠ¤í…œì— ë“±ë¡ëœ ëª¨ë“  ë³€í™˜ê¸° + ë™ì  ìƒì„± ë³€í™˜ê¸° í•¨ê»˜ ì‚¬ìš©
        List<ValueConverter> allConverters = new ArrayList<>(pluginManager.getAllValueConverters());
        allConverters.add(customConverter);
        
        // ë¹Œë” êµ¬ì„± ë° ì¶œë ¥
        excelBuilder.create()
                   .document(AdvancedReportDoc.class)
                   .locale(locale)
                   .sheetData("Report", data)
                   .addConverters(allConverters)    // ë‹¤ì¤‘ ë³€í™˜ê¸° ì¶”ê°€
                   .addValidators(pluginManager.getAllValidators())  // ëª¨ë“  ê²€ì¦ê¸° ì¶”ê°€
                   .write(response.getOutputStream());
    }
    
    private List<AdvancedReportDto> prepareReportData() {
        // í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
        return IntStream.range(1, 11)
                .mapToObj(i -> {
                    AdvancedReportDto dto = new AdvancedReportDto();
                    dto.setId(i);
                    dto.setName("Item " + i);
                    dto.setAmount(BigDecimal.valueOf(i * 1000 + Math.random() * 100));
                    dto.setStatus(i % 2 == 0 ? "P" + i : "C" + i);
                    dto.setCreatedDate(LocalDate.now().minusDays(i));
                    dto.setPhone("010-1234-" + (1000 + i));
                    return dto;
                })
                .collect(Collectors.toList());
    }
}
```

## 6. i18n í—¤ë”ì™€ ê¸€ë¡œë²Œ ìŠ¤íƒ€ì¼

### 6.1. application.yml ì„¤ì •

```yaml
excel:
  # ì—”ì§„ íƒ€ì…: inMemory ë˜ëŠ” streaming
  engine: streaming
  
  # ìŠ¤íŠ¸ë¦¬ë° ì„¤ì •
  streaming:
    window-size: 100  # ë©”ëª¨ë¦¬ì— ìœ ì§€í•  í–‰ ìˆ˜
  
  # ê¸°ë³¸ ìŠ¤íƒ€ì¼ ì„¤ì •
  default:
    font:
      name: "Arial"
      size: 11
      color: "#000000"
    header:
      font:
        name: "Arial"
        size: 12
        bold: true
        color: "#FFFFFF"
      bgColor: "#4472C4"
      align: CENTER
    border:
      all: THIN
    align: CENTER
    wrapText: false
  
  # ë‚ ì§œ/ì‹œê°„ í¬ë§·
  date:
    format: "yyyy-MM-dd"
  datetime:
    format: "yyyy-MM-dd HH:mm:ss"
```

### 6.2. ìŠ¤í”„ë§ ë¶€íŠ¸ ìë™ ì„¤ì •

```java
@Configuration
@EnableConfigurationProperties(ExcelProperties.class)
@ConditionalOnClass(Workbook.class)
@ComponentScan("com.example.excel")
public class ExcelAutoConfiguration {

    private final ExcelProperties properties;
    
    public ExcelAutoConfiguration(ExcelProperties properties) {
        this.properties = properties;
    }
    
    @Bean
    @ConditionalOnMissingBean
    public ExcelEngine excelEngine(StyleManager styleManager) {
        if ("streaming".equals(properties.getEngine())) {
            return new StreamingExcelEngine(
                styleManager, 
                properties.getStreaming().getWindowSize()
            );
        } else {
            return new InMemoryExcelEngine(styleManager);
        }
    }
    
    @Bean
    @ConditionalOnMissingBean
    public I18nResolver i18nResolver(MessageSource messageSource) {
        return new I18nResolverImpl(messageSource);
    }
    
    @Bean
    @ConditionalOnMissingBean
    public StyleManager styleManager() {
        return new StyleManagerImpl(properties.getDefault());
    }
    
    @Bean
    @ConditionalOnMissingBean
    public ExcelBuilder excelBuilder(ExcelEngine engine, I18nResolver i18nResolver) {
        return new ExcelBuilderImpl(engine, i18nResolver);
    }
}

@ConfigurationProperties(prefix = "excel")
@Data
public class ExcelProperties {
    private String engine = "inMemory";
    private StreamingProperties streaming = new StreamingProperties();
    private DefaultStyleProperties defaults = new DefaultStyleProperties();
    private DateFormatProperties date = new DateFormatProperties();
    
    @Data
    public static class StreamingProperties {
        private int windowSize = 100;
    }
    
    @Data
    public static class DefaultStyleProperties {
        private FontProperties font = new FontProperties();
        private HeaderProperties header = new HeaderProperties();
        private BorderProperties border = new BorderProperties();
        private String align = "CENTER";
        private boolean wrapText = false;
    }
    
    @Data
    public static class FontProperties {
        private String name = "Arial";
        private int size = 11;
        private String color = "#000000";
        private boolean bold = false;
    }
    
    @Data
    public static class HeaderProperties {
        private FontProperties font = new FontProperties();
        private String bgColor = "#4472C4";
        private String align = "CENTER";
    }
    
    @Data
    public static class BorderProperties {
        private String all = "THIN";
    }
    
    @Data
    public static class DateFormatProperties {
        private String format = "yyyy-MM-dd";
    }
}
```

### 6.3. ë‹¤êµ­ì–´ í—¤ë”

```properties
# messages_ko.properties
user.id=ë²ˆí˜¸
user.name=ì´ë¦„
user.email=ì´ë©”ì¼
user.grade=ë“±ê¸‰
user.joinDate=ê°€ì…ì¼

# messages_en.properties
user.id=ID
user.name=Name
user.email=Email
user.grade=Grade
user.joinDate=Join Date
```

```java
/**
 * i18n ë¦¬ì¡¸ë²„ ì¸í„°í˜ì´ìŠ¤
 */
public interface I18nResolver {
    /**
     * í‚¤ì— í•´ë‹¹í•˜ëŠ” ë‹¤êµ­ì–´ ë©”ì‹œì§€ ì¡°íšŒ
     */
    String getMessage(String key, Locale locale);
    
    /**
     * ì¸ìê°€ ìˆëŠ” ë‹¤êµ­ì–´ ë©”ì‹œì§€ ì¡°íšŒ
     */
    String getMessage(String key, Object[] args, Locale locale);
    
    /**
     * ëª¨ë“  Locale ì§€ì› ì—¬ë¶€ í™•ì¸
     */
    boolean supportsAllLocales();
    
    /**
     * ì§€ì›í•˜ëŠ” Locale ëª©ë¡ ì¡°íšŒ
     */
    List<Locale> getSupportedLocales();
}

/**
 * i18n ë¦¬ì¡¸ë²„ ê¸°ë³¸ êµ¬í˜„ì²´
 */
public class I18nResolverImpl implements I18nResolver {
    private final MessageSource messageSource;
    
    public I18nResolverImpl(MessageSource messageSource) {
        this.messageSource = messageSource;
    }
    
    @Override
    public String getMessage(String key, Locale locale) {
        return getMessage(key, null, locale);
    }
    
    @Override
    public String getMessage(String key, Object[] args, Locale locale) {
        try {
            return messageSource.getMessage(key, args, key, locale);
        } catch (NoSuchMessageException e) {
            return key; // ë©”ì‹œì§€ ì—†ì„ ê²½ìš° í‚¤ ê·¸ëŒ€ë¡œ ë°˜í™˜
        }
    }
    
    @Override
    public boolean supportsAllLocales() {
        return true; // ê¸°ë³¸ êµ¬í˜„ì€ ëª¨ë“  ë¡œì¼€ì¼ ì§€ì› ê°€ëŠ¥
    }
    
    @Override
    public List<Locale> getSupportedLocales() {
        // ê¸°ë³¸ì ìœ¼ë¡œ ì§€ì› ê°€ëŠ¥í•œ ëª¨ë“  ë¡œì¼€ì¼ ë°˜í™˜
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë“±ë¡ëœ ë©”ì‹œì§€ ì†ŒìŠ¤ì— ë”°ë¼ ê²°ì •
        return Arrays.asList(Locale.getAvailableLocales());
    }
}

/**
 * ë‹¤ì¤‘ ë©”ì‹œì§€ ì†ŒìŠ¤ ì§€ì› i18n ë¦¬ì¡¸ë²„
 */
public class CompositeI18nResolver implements I18nResolver {
    private final List<I18nResolver> resolvers;
    
    public CompositeI18nResolver(I18nResolver... resolvers) {
        this.resolvers = Arrays.asList(resolvers);
    }
    
    public CompositeI18nResolver(Collection<I18nResolver> resolvers) {
        this.resolvers = new ArrayList<>(resolvers);
    }
    
    @Override
    public String getMessage(String key, Locale locale) {
        return getMessage(key, null, locale);
    }
    
    @Override
    public String getMessage(String key, Object[] args, Locale locale) {
        // ëª¨ë“  ë¦¬ì¡¸ë²„ì—ì„œ ìˆœì°¨ì ìœ¼ë¡œ ì¡°íšŒ ì‹œë„
        for (I18nResolver resolver : resolvers) {
            try {
                String message = resolver.getMessage(key, args, locale);
                // í‚¤ì™€ ë™ì¼í•˜ì§€ ì•Šì€ ê²½ìš° = ë©”ì‹œì§€ë¥¼ ì°¾ì€ ê²½ìš°
                if (!message.equals(key)) {
                    return message;
                }
            } catch (Exception ignored) {
                // ë‹¤ìŒ ë¦¬ì¡¸ë²„ë¡œ ì‹œë„
            }
        }
        
        // ëª¨ë“  ë¦¬ì¡¸ë²„ì—ì„œ í‚¤ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° í‚¤ ê·¸ëŒ€ë¡œ ë°˜í™˜
        return key;
    }
    
    @Override
    public boolean supportsAllLocales() {
        // í•˜ë‚˜ë¼ë„ ëª¨ë“  ë¡œì¼€ì¼ì„ ì§€ì›í•˜ë©´ true
        return resolvers.stream().anyMatch(I18nResolver::supportsAllLocales);
    }
    
    @Override
    public List<Locale> getSupportedLocales() {
        // ëª¨ë“  ë¦¬ì¡¸ë²„ì˜ ì§€ì› ë¡œì¼€ì¼ í•©ì§‘í•©
        Set<Locale> locales = new HashSet<>();
        resolvers.forEach(r -> locales.addAll(r.getSupportedLocales()));
        return new ArrayList<>(locales);
    }
}
```

### 6.4. ìŠ¤íƒ€ì¼ ë§¤ë‹ˆì €

```java
/**
 * ì…€ ìŠ¤íƒ€ì¼ ê´€ë¦¬ì ì¸í„°í˜ì´ìŠ¤
 */
public interface StyleManager {
    /**
     * í—¤ë” ìŠ¤íƒ€ì¼ ìƒì„±
     */
    CellStyle getHeaderStyle(ExcelCellStyle style, Workbook workbook);
    
    /**
     * ë°ì´í„° ì…€ ìŠ¤íƒ€ì¼ ìƒì„±
     */
    CellStyle getDataStyle(ExcelCellStyle style, Workbook workbook);
}

/**
 * ìŠ¤íƒ€ì¼ ë§¤ë‹ˆì € êµ¬í˜„ì²´
 */
public class StyleManagerImpl implements StyleManager {
    private final DefaultStyleProperties defaultProps;
    private final Map<String, CellStyle> styleCache = new HashMap<>();
    
    public StyleManagerImpl(DefaultStyleProperties defaultProps) {
        this.defaultProps = defaultProps;
    }
    
    @Override
    public CellStyle getHeaderStyle(ExcelCellStyle style, Workbook workbook) {
        String styleKey = "header-" + getStyleKey(style);
        
        // ìºì‹±ëœ ìŠ¤íƒ€ì¼ ë°˜í™˜
        if (styleCache.containsKey(styleKey)) {
            return styleCache.get(styleKey);
        }
        
        // ìƒˆ í—¤ë” ìŠ¤íƒ€ì¼ ìƒì„±
        CellStyle cellStyle = workbook.createCellStyle();
        
        // í°íŠ¸ ì„¤ì •
        Font font = workbook.createFont();
        font.setFontName(getOrDefault(style.fontName(), defaultProps.getHeader().getFont().getName()));
        font.setFontHeightInPoints(getOrDefault(style.fontSize(), defaultProps.getHeader().getFont().getSize()));
        font.setBold(getOrDefault(style.bold(), defaultProps.getHeader().getFont().isBold()));
        
        // í°íŠ¸ ìƒ‰ìƒ
        String fontColor = getOrDefault(style.fontColor(), defaultProps.getHeader().getFont().getColor());
        setFontColor(font, fontColor);
        
        cellStyle.setFont(font);
        
        // ë°°ê²½ìƒ‰
        String bgColor = getOrDefault(style.bgColor(), defaultProps.getHeader().getBgColor());
        setCellBgColor(cellStyle, bgColor);
        
        // ì •ë ¬
        setCellAlignment(cellStyle, style.hAlign(), style.vAlign());
        
        // í…Œë‘ë¦¬
        setCellBorder(cellStyle, style.border());
        
        // ìë™ ì¤„ë°”ê¿ˆ
        cellStyle.setWrapText(getOrDefault(style.wrapText(), defaultProps.isWrapText()));
        
        // ìºì‹œì— ì €ì¥
        styleCache.put(styleKey, cellStyle);
        
        return cellStyle;
    }
    
    @Override
    public CellStyle getDataStyle(ExcelCellStyle style, Workbook workbook) {
        String styleKey = "data-" + getStyleKey(style);
        
        // ìºì‹±ëœ ìŠ¤íƒ€ì¼ ë°˜í™˜
        if (styleCache.containsKey(styleKey)) {
            return styleCache.get(styleKey);
        }
        
        // ìƒˆ ë°ì´í„° ìŠ¤íƒ€ì¼ ìƒì„±
        CellStyle cellStyle = workbook.createCellStyle();
        
        // í°íŠ¸ ì„¤ì •
        Font font = workbook.createFont();
        font.setFontName(getOrDefault(style.fontName(), defaultProps.getFont().getName()));
        font.setFontHeightInPoints(getOrDefault(style.fontSize(), defaultProps.getFont().getSize()));
        font.setBold(getOrDefault(style.bold(), defaultProps.getFont().isBold()));
        
        // í°íŠ¸ ìƒ‰ìƒ
        String fontColor = getOrDefault(style.fontColor(), defaultProps.getFont().getColor());
        setFontColor(font, fontColor);
        
        cellStyle.setFont(font);
        
        // ë°°ê²½ìƒ‰
        if (!style.bgColor().isEmpty()) {
            setCellBgColor(cellStyle, style.bgColor());
        }
        
        // ì •ë ¬
        setCellAlignment(cellStyle, style.hAlign(), style.vAlign());
        
        // í…Œë‘ë¦¬
        setCellBorder(cellStyle, style.border());
        
        // ìë™ ì¤„ë°”ê¿ˆ
        cellStyle.setWrapText(getOrDefault(style.wrapText(), defaultProps.isWrapText()));
        
        // ìºì‹œì— ì €ì¥
        styleCache.put(styleKey, cellStyle);
        
        return cellStyle;
    }
    
    // í—¬í¼ ë©”ì„œë“œë“¤...
    private String getStyleKey(ExcelCellStyle style) {
        // ìŠ¤íƒ€ì¼ì˜ ê³ ìœ  í‚¤ ìƒì„± ë¡œì§
        return style.fontName() + style.fontSize() + style.fontColor() + 
               style.bgColor() + style.hAlign() + style.vAlign() + style.border();
    }
    
    private <T> T getOrDefault(T value, T defaultValue) {
        if (value == null || (value instanceof String && ((String) value).isEmpty()) || 
            (value instanceof Number && ((Number) value).intValue() < 0)) {
            return defaultValue;
        }
        return value;
    }
    
    private void setFontColor(Font font, String colorHex) {
        if (colorHex != null && !colorHex.isEmpty()) {
            IndexedColors idxColor = getIndexedColorFromHex(colorHex);
            if (idxColor != null) {
                font.setColor(idxColor.getIndex());
            } else if (font instanceof XSSFFont) {
                ((XSSFFont) font).setColor(new XSSFColor(hexToRGB(colorHex), null));
            }
        }
    }
    
    private void setCellBgColor(CellStyle style, String colorHex) {
        if (colorHex != null && !colorHex.isEmpty()) {
            IndexedColors idxColor = getIndexedColorFromHex(colorHex);
            if (idxColor != null) {
                style.setFillForegroundColor(idxColor.getIndex());
            } else if (style instanceof XSSFCellStyle) {
                ((XSSFCellStyle) style).setFillForegroundColor(
                    new XSSFColor(hexToRGB(colorHex), null));
            }
            style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
        }
    }
    
    private void setCellAlignment(CellStyle style, HAlign hAlign, VAlign vAlign) {
        // ê°€ë¡œ ì •ë ¬
        if (hAlign != HAlign.DEFAULT) {
            style.setAlignment(switch (hAlign) {
                case LEFT -> HorizontalAlignment.LEFT;
                case CENTER -> HorizontalAlignment.CENTER;
                case RIGHT -> HorizontalAlignment.RIGHT;
                default -> HorizontalAlignment.CENTER;
            });
        } else {
            // ê¸°ë³¸ ê°€ë¡œ ì •ë ¬
            style.setAlignment(HorizontalAlignment.valueOf(defaultProps.getAlign()));
        }
        
        // ì„¸ë¡œ ì •ë ¬
        if (vAlign != VAlign.DEFAULT) {
            style.setVerticalAlignment(switch (vAlign) {
                case TOP -> VerticalAlignment.TOP;
                case MIDDLE -> VerticalAlignment.CENTER;
                case BOTTOM -> VerticalAlignment.BOTTOM;
                default -> VerticalAlignment.CENTER;
            });
        } else {
            // ê¸°ë³¸ ì„¸ë¡œ ì •ë ¬
            style.setVerticalAlignment(VerticalAlignment.CENTER);
        }
    }
    
    private void setCellBorder(CellStyle style, BorderStyle border) {
        org.apache.poi.ss.usermodel.BorderStyle poiBorder;
        
        if (border == BorderStyle.DEFAULT) {
            // ê¸°ë³¸ í…Œë‘ë¦¬ ìŠ¤íƒ€ì¼
            poiBorder = org.apache.poi.ss.usermodel.BorderStyle.valueOf(defaultProps.getBorder().getAll());
        } else {
            // ì§€ì •ëœ í…Œë‘ë¦¬ ìŠ¤íƒ€ì¼
            poiBorder = switch (border) {
                case NONE -> org.apache.poi.ss.usermodel.BorderStyle.NONE;
                case THIN -> org.apache.poi.ss.usermodel.BorderStyle.THIN;
                case MEDIUM -> org.apache.poi.ss.usermodel.BorderStyle.MEDIUM;
                case THICK -> org.apache.poi.ss.usermodel.BorderStyle.THICK;
                default -> org.apache.poi.ss.usermodel.BorderStyle.THIN;
            };
        }
        
        // ìƒí•˜ì¢Œìš° ëª¨ë“  í…Œë‘ë¦¬ì— ì ìš©
        style.setBorderTop(poiBorder);
        style.setBorderRight(poiBorder);
        style.setBorderBottom(poiBorder);
        style.setBorderLeft(poiBorder);
    }
    
    // ìƒ‰ìƒ ë³€í™˜ í—¬í¼ ë©”ì„œë“œë“¤...
    private byte[] hexToRGB(String colorHex) {
        if (colorHex.startsWith("#")) {
            colorHex = colorHex.substring(1);
        }
        
        int r = Integer.parseInt(colorHex.substring(0, 2), 16);
        int g = Integer.parseInt(colorHex.substring(2, 4), 16);
        int b = Integer.parseInt(colorHex.substring(4, 6), 16);
        
        return new byte[] { (byte) r, (byte) g, (byte) b };
    }
    
    private IndexedColors getIndexedColorFromHex(String colorHex) {
        // ì¼ë°˜ì ì¸ ìƒ‰ìƒ ë§¤í•‘ (ìµœì í™”ë¥¼ ìœ„í•´)
        return switch (colorHex.toUpperCase()) {
            case "#000000" -> IndexedColors.BLACK;
            case "#FFFFFF" -> IndexedColors.WHITE;
            case "#FF0000" -> IndexedColors.RED;
            case "#00FF00" -> IndexedColors.GREEN;
            case "#0000FF" -> IndexedColors.BLUE;
            case "#FFFF00" -> IndexedColors.YELLOW;
            // ... ë” ë§ì€ ìƒ‰ìƒ ë§¤í•‘
            default -> null; // ë§¤í•‘ ì—†ìŒ, XSSFColor ì‚¬ìš©
        };
    }
}
```

## 7. ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ

### 7.1. ë¬¸ì„œ ë° DTO í´ë˜ìŠ¤ ì •ì˜

```java
/**
 * ì „ì²´ ë³´ê³ ì„œ ë¬¸ì„œ ì •ì˜
 */
@ExcelDocument(
  fileName = "full_report.xlsx",
  sheets = {
    @SheetConfig(name="Summary", dto=SummaryDto.class, startCell="B3"),
    @SheetConfig(name="Details", dto=DetailDto.class)
  }
)
public class FullReportDoc {}

/**
 * ìš”ì•½ ì •ë³´ DTO
 */
public class SummaryDto {
    @ExcelColumn(order=0, headerKey="summary.category")
    private String category;
    
    @ExcelColumn(order=1, headerKey="summary.count")
    private Integer count;
    
    @ExcelColumn(order=2, headerKey="summary.amount", 
                dataStyle=@ExcelCellStyle(hAlign=HAlign.RIGHT))
    private BigDecimal amount;
    
    // getters and setters
}

/**
 * ìƒì„¸ ì •ë³´ DTO
 */
public class DetailDto {
    @ExcelColumn(order=0, headerKey="user.id")
    @NotEmpty(message="ì‚¬ìš©ì IDëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤")
    private String userId;
    
    @ExcelColumn(order=1, headerKey="user.name")
    @NotEmpty
    @MaxLength(100)
    private String name;
    
    @ExcelColumn(order=2, headerKey="user.email")
    @NotEmpty
    private String email;
    
    @ExcelColumn(order=3, headerKey="user.grade")
    private String grade;  // "G", "S", "B" ë“±ì˜ ì½”ë“œ ê°’
    
    @ExcelColumn(order=4, headerKey="user.joinDate")
    private LocalDate joinDate;
    
    // getters and setters
}
```

### 7.2. ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ì‚¬ìš©

```java
@RestController
@RequiredArgsConstructor
public class ReportController {
    private final ExcelBuilder excelBuilder;
    private final ReportService reportService;
    private final GradeConverter gradeConverter;
    private final AnnotationValidator validator;
    private final I18nResolver i18nResolver;

    /**
     * ì¼ë°˜ì ì¸ ë¹Œë” API ì‚¬ìš© ë°©ì‹
     */
    @GetMapping("/report/download")
    public void downloadReport(HttpServletResponse response, Locale locale) throws IOException {
        // ë°ì´í„° ì¡°íšŒ
        List<SummaryDto> summaries = reportService.getSummaries();
        List<DetailDto> details = reportService.getDetails();
        
        // ì‘ë‹µ í—¤ë” ì„¤ì •
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setHeader("Content-Disposition", "attachment; filename=full_report.xlsx");

        // ì—‘ì…€ ë¹Œë”ë¡œ ë¬¸ì„œ ìƒì„± ë° ì¶œë ¥
        excelBuilder.create()
                   .document(FullReportDoc.class)  // ë¬¸ì„œ êµ¬ì¡° ì •ì˜
                   .locale(locale)                 // ë‹¤êµ­ì–´ ì„¤ì •
                   .sheetData("Summary", summaries) // ì‹œíŠ¸ë³„ ë°ì´í„°
                   .sheetData("Details", details)
                   .addConverter(gradeConverter)    // ê°’ ë³€í™˜ê¸° ì¶”ê°€
                   .addValidator(validator)         // ê²€ì¦ê¸° ì¶”ê°€
                   .i18nResolver(i18nResolver)      // ë‹¤êµ­ì–´ ë¦¬ì¡¸ë²„ ì„¤ì •
                   .write(response.getOutputStream());
    }
    
    /**
     * ì—¬ëŸ¬ ë³€í™˜ê¸°ì™€ ê²€ì¦ê¸°ë¥¼ í•œ ë²ˆì— ì¶”ê°€í•˜ëŠ” ë°©ì‹
     */
    @GetMapping("/report/download-multi")
    public void downloadReportWithMulti(HttpServletResponse response, Locale locale) throws IOException {
        // ë°ì´í„° ì¡°íšŒ
        List<SummaryDto> summaries = reportService.getSummaries();
        List<DetailDto> details = reportService.getDetails();
        
        // ë³€í™˜ê¸° ëª©ë¡ ì¤€ë¹„
        List<ValueConverter> converters = List.of(
            gradeConverter,
            new DateFormatConverter(),
            new CodeValueConverter()
        );
        
        // ê²€ì¦ê¸° ëª©ë¡ ì¤€ë¹„
        List<Validator> validators = List.of(
            validator,
            new CustomBusinessValidator()
        );
        
        // ì‘ë‹µ í—¤ë” ì„¤ì •
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setHeader("Content-Disposition", "attachment; filename=full_report.xlsx");

        // ì—‘ì…€ ë¹Œë”ë¡œ ë¬¸ì„œ ìƒì„± ë° ì¶œë ¥ - ë‹¤ì¤‘ ì»¨ë²„í„°/ê²€ì¦ê¸° ì¶”ê°€
        excelBuilder.create()
                   .document(FullReportDoc.class)    // ë¬¸ì„œ êµ¬ì¡° ì •ì˜
                   .locale(locale)                   // ë‹¤êµ­ì–´ ì„¤ì •
                   .sheetData("Summary", summaries)  // ì‹œíŠ¸ë³„ ë°ì´í„°
                   .sheetData("Details", details)
                   .addConverters(converters)        // ë‹¤ì¤‘ ë³€í™˜ê¸° ì¶”ê°€
                   .addValidators(validators)        // ë‹¤ì¤‘ ê²€ì¦ê¸° ì¶”ê°€
                   .i18nResolver(i18nResolver)       // ë‹¤êµ­ì–´ ë¦¬ì¡¸ë²„ ì„¤ì •
                   .write(response.getOutputStream());
    }
    
/**
 * ê°€ë³€ ì¸ìë¥¼ ì‚¬ìš©í•œ ë°©ì‹
 */
@GetMapping("/report/download-varargs")
public void downloadReportWithVararg(HttpServletResponse response, Locale locale) throws IOException {
    // ë°ì´í„° ì¡°íšŒ
    List<SummaryDto> summaries = reportService.getSummaries();
    List<DetailDto> details = reportService.getDetails();
        
    // ì‘ë‹µ í—¤ë” ì„¤ì •
    response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    response.setHeader("Content-Disposition", "attachment; filename=full_report.xlsx");

    // ì—‘ì…€ ë¹Œë”ë¡œ ë¬¸ì„œ ìƒì„± ë° ì¶œë ¥ - ê°€ë³€ ì¸ìë¡œ ë‹¤ì¤‘ ì¶”ê°€
    excelBuilder.create()
            .document(FullReportDoc.class)    // ë¬¸ì„œ êµ¬ì¡° ì •ì˜
            .locale(locale)                   // ë‹¤êµ­ì–´ ì„¤ì •
            .sheetData("Summary", summaries)  // ì‹œíŠ¸ë³„ ë°ì´í„°
            .sheetData("Details", details)
            .addConverters(                   // ê°€ë³€ ì¸ìë¡œ ì—¬ëŸ¬ ë³€í™˜ê¸° ì¶”ê°€
                gradeConverter,
                new DateFormatConverter(),
                new CodeValueConverter()
            )
            .addValidators(                   // ê°€ë³€ ì¸ìë¡œ ì—¬ëŸ¬ ê²€ì¦ê¸° ì¶”ê°€
               validator,
               new CustomBusinessValidator()
            )
            .i18nResolver(i18nResolver)       // ë‹¤êµ­ì–´ ë¦¬ì¡¸ë²„ ì„¤ì •
            .write(response.getOutputStream());
}
    
/**
 * AOP ë°©ì‹ìœ¼ë¡œ ê°„í¸í•˜ê²Œ ì‚¬ìš©
 */
@GetMapping("/report/download-aop")
@ExcelResponse(documentClass = FullReportDoc.class)
public Map<String, List<?>> downloadReportAOP(Locale locale) {
    // AOPì—ì„œ @ExcelResponse ì• ë…¸í…Œì´ì…˜ì„ ê°ì§€í•˜ì—¬ ê²°ê³¼ë¥¼ ì—‘ì…€ë¡œ ë³€í™˜
    Map<String, List<?>> sheetData = new HashMap<>();
    sheetData.put("Summary", reportService.getSummaries());
    sheetData.put("Details", reportService.getDetails());
        
    return sheetData;
}

/**
 * AOPë¥¼ ìœ„í•œ ì• ë…¸í…Œì´ì…˜
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ExcelResponse {
    Class<?> documentClass();
    String fileName() default "";
}

/**
 * ì—‘ì…€ ì‘ë‹µ AOP ì–´ë“œë°”ì´ìŠ¤
 */
@Aspect
@Component
@RequiredArgsConstructor
public class ExcelResponseAspect {
    private final ExcelBuilder excelBuilder;
    private final GradeConverter gradeConverter;
    private final AnnotationValidator validator;
    private final I18nResolver i18nResolver;
    
    @Around("@annotation(excelResponse)")
    public Object handleExcelResponse(ProceedingJoinPoint joinPoint, ExcelResponse excelResponse) throws Throwable {
        // ì›ë³¸ ë©”ì„œë“œ ì‹¤í–‰
        Object result = joinPoint.proceed();
        
        if (!(result instanceof Map)) {
            throw new IllegalStateException("Method with @ExcelResponse must return Map<String, List<?>>");
        }
        
        // HTTP ì‘ë‹µ ê°ì²´ ê°€ì ¸ì˜¤ê¸°
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        HttpServletResponse response = ((ServletRequestAttributes) requestAttributes)
            .getResponse();
        
        // Locale ê°€ì ¸ì˜¤ê¸°
        Locale locale = LocaleContextHolder.getLocale();
        
        // ì—‘ì…€ ë¬¸ì„œ í´ë˜ìŠ¤ ì •ë³´
        Class<?> documentClass = excelResponse.documentClass();
        
        // ì—‘ì…€ íŒŒì¼ëª… ê°€ì ¸ì˜¤ê¸°
        String filename;
        if (!excelResponse.fileName().isEmpty()) {
            filename = excelResponse.fileName();
        } else {
            ExcelDocument docAnno = documentClass.getAnnotation(ExcelDocument.class);
            filename = docAnno.fileName();
        }
        
        // ì‘ë‹µ í—¤ë” ì„¤ì •
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setHeader("Content-Disposition", "attachment; filename=" + filename);
        
        // ì—‘ì…€ ë¹Œë” êµ¬ì„± ë° ì¶œë ¥
        ExcelBuilder builder = excelBuilder.create()
                                .document(documentClass)
                                .locale(locale)
                                .addConverter(gradeConverter)
                                .addValidator(validator)
                                .i18nResolver(i18nResolver);
        
        // ì‹œíŠ¸ë³„ ë°ì´í„° ì¶”ê°€
        @SuppressWarnings("unchecked")
        Map<String, List<?>> sheetData = (Map<String, List<?>>) result;
        for (Map.Entry<String, List<?>> entry : sheetData.entrySet()) {
            builder.sheetData(entry.getKey(), entry.getValue());
        }
        
        // ì¶œë ¥
        builder.write(response.getOutputStream());
        
        return null; // ì´ë¯¸ ì‘ë‹µì´ ì‘ì„±ë˜ì—ˆìœ¼ë¯€ë¡œ null ë°˜í™˜
    }
}
```

## 8. ì„±ëŠ¥ ìµœì í™” ë° ëŒ€ìš©ëŸ‰ ì²˜ë¦¬

### 8.1. ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬ì˜ ì‹¤ì œ ì„±ëŠ¥

ìŠ¤íŠ¸ë¦¬ë° ì—”ì§„(`SXSSFWorkbook`)ì€ Apache POIì˜ ì¼ë°˜ ì›Œí¬ë¶(`XSSFWorkbook`)ì— ë¹„í•´ ëŒ€ìš©ëŸ‰ ì²˜ë¦¬ì—ì„œ í° ì¥ì ì„ ì œê³µí•©ë‹ˆë‹¤. ê°„ë‹¨í•œ ë²¤ì¹˜ë§ˆí¬ë¥¼ í†µí•´ ì°¨ì´ë¥¼ í™•ì¸í•´ ë³´ê² ìŠµë‹ˆë‹¤

|  í–‰ ìˆ˜   | XSSFWorkbook (ë©”ëª¨ë¦¬) | SXSSFWorkbook (100í–‰ ìœˆë„ìš°) |
|---------|-----------------------|----------------------------|
| 1ë§Œ í–‰   | 150MB                 | 35MB                       |
| 10ë§Œ í–‰  | 1.1GB                 | 40MB                       |
| 100ë§Œ í–‰ | OOM ë°œìƒ               | 45MB                       |

`SXSSFWorkbook`ì€ ë©”ëª¨ë¦¬ì— ì§€ì •ëœ ìœˆë„ìš° í¬ê¸°ë§Œí¼ì˜ í–‰ë§Œ ìœ ì§€í•˜ê³ , ë‚˜ë¨¸ì§€ëŠ” ì„ì‹œ íŒŒì¼ë¡œ ê´€ë¦¬í•˜ê¸° ë•Œë¬¸ì— ëŒ€ìš©ëŸ‰ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

### ì¶”ê°€ì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ìµœì í™” ë°©ë²•

1. **ë¹„ë™ê¸° ì²˜ë¦¬**: ëŒ€ìš©ëŸ‰ ì²˜ë¦¬ ì‹œ ë¹„ë™ê¸°ë¡œ íŒŒì¼ ìƒì„± í›„ ë‹¤ìš´ë¡œë“œ URL ë°˜í™˜ ()
   ```java
   @Async
   public CompletableFuture<String> generateExcelAsync(Class<?> docClass, Map<String, List<?>> data) {
       String fileId = UUID.randomUUID().toString();
       String filePath = "/tmp/" + fileId + ".xlsx";
       
       try (FileOutputStream fos = new FileOutputStream(filePath)) {
           excelBuilder.create()
                     .document(docClass)
                     .sheetData(/* ... */)
                     .write(fos);
       }
       
       return CompletableFuture.completedFuture("/download/file/" + fileId);
   }
   ```

2. **LRU ìºì‹œ**: ìì£¼ ì‚¬ìš©ë˜ëŠ” ìŠ¤íƒ€ì¼, í¬ë§· ë“±ì„ ìºì‹±
   ```java
   @Bean
   public CacheManager cacheManager() {
       return new ConcurrentMapCacheManager("excelStyles", "excelFormats");
   }
   ```

3. **ë¶„í•  ì²˜ë¦¬**: ë°ì´í„°ë¥¼ ì²­í¬ë¡œ ë‚˜ëˆ„ì–´ ì²˜ë¦¬
   ```java
   public void writeDataInChunks(Sheet sheet, SheetMeta meta, List<?> allData) {
       int rowIdx = meta.getDataStartCell().getRow();
       int chunkSize = 1000;
       
       for (int i = 0; i < allData.size(); i += chunkSize) {
           int end = Math.min(i + chunkSize, allData.size());
           List<?> chunk = allData.subList(i, end);
           
           // ì²­í¬ ì²˜ë¦¬
           for (Object dto : chunk) {
               writeDataRow(sheet.createRow(rowIdx++), dto, meta);
           }
       }
   }
   ```

4. **ë©”ëª¨ë¦¬ ëª¨ë‹ˆí„°ë§**: JVM ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ì„ í†µí•œ ì ì ˆí•œ ì²­í¬ í¬ê¸° ì¡°ì •
   ```java
   private int determineOptimalChunkSize() {
       Runtime runtime = Runtime.getRuntime();
       long maxMemory = runtime.maxMemory();
       long usedMemory = runtime.totalMemory() - runtime.freeMemory();
       long availableMemory = maxMemory - usedMemory;
       
       // ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ì— ë”°ë¼ ì²­í¬ í¬ê¸° ì¡°ì •
       if (availableMemory < 100_000_000) { // 100MB ë¯¸ë§Œ
           return 500;
       } else if (availableMemory < 500_000_000) { // 500MB ë¯¸ë§Œ
           return 1000;
       } else {
           return 2000;
       }
   }
   ```

5. **ë³‘ë ¬ ì²˜ë¦¬**: ì—¬ëŸ¬ ì‹œíŠ¸ë¥¼ ë³‘ë ¬ë¡œ ì²˜ë¦¬í•˜ëŠ” ë°©ì‹ (ì£¼ì˜: ìŠ¤ë ˆë“œ ì•ˆì „ì„± ê³ ë ¤ í•„ìš”)
   ```java
   private void processAllSheetsInParallel(Workbook wb, ExcelMeta meta, Map<String, List<?>> dataMap) {
       ExecutorService executor = Executors.newFixedThreadPool(
           Math.min(meta.getSheets().size(), Runtime.getRuntime().availableProcessors())
       );
       
       List<Future<?>> futures = new ArrayList<>();
       
       // ê° ì‹œíŠ¸ë¥¼ ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ì²˜ë¦¬
       for (SheetMeta sheetMeta : meta.getSheets()) {
           futures.add(executor.submit(() -> {
               Sheet sheet = wb.createSheet(sheetMeta.getName());
               List<?> data = dataMap.get(sheetMeta.getName());
               // ì‹œíŠ¸ ì²˜ë¦¬ ë¡œì§...
               return null;
           }));
       }
       
       // ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
       for (Future<?> future : futures) {
           try {
               future.get();
           } catch (Exception e) {
               throw new ExcelException("Error processing sheet", e);
           }
       }
       
       executor.shutdown();
   }
   ```

## ë§ˆì¹¨

ì—¬ê¸°ê¹Œì§€ ë”°ë¼ì˜¤ëŠë¼ ê³ ìƒ ë§ìœ¼ì…¨ìŠµë‹ˆë‹¤.
ì§€ê¸ˆê¹Œì§€ ë§Œë“  ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ëª¨ë“ˆì€ ë”± ë‘ ê°€ì§€ë¡œ ìš”ì•½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
1. ë°˜ë³µ ì½”ë“œë¥¼ ì‹¹ ëœì–´ë‚¸ ê¹”ë”í•œ êµ¬ì¡°
- ì–´ë…¸í…Œì´ì…˜ê³¼ ë¹Œë” íŒ¨í„´ìœ¼ë¡œ ì„¤ì •ì„ í•œëˆˆì— íŒŒì•…í•  ìˆ˜ ìˆì–´ìš”.
- ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œëŠ” ExcelBuilder.create()â€¦write() í•œ ì¤„ì´ë©´ ë!
2. ëŒ€ìš©ëŸ‰Â·ë‹¤êµ­ì–´Â·ê²€ì¦Â·ìŠ¤íƒ€ì¼ë§ê¹Œì§€ í•œ ë²ˆì—
- SXSSF ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ìˆ˜ë°±ë§Œ ê±´ë„ ë¶€ë‹´ ì—†ì´ ì²˜ë¦¬
- ë©”ì‹œì§€ ë¦¬ì†ŒìŠ¤ë¥¼ ì´ìš©í•´ ìë™ìœ¼ë¡œ ë‹¤êµ­ì–´ í—¤ë” ì ìš©
- ValidatorÂ·Formatter í”ŒëŸ¬ê·¸ì¸ìœ¼ë¡œ í•„ìˆ˜ ê²€ì¦Â·í¬ë§· ì»¤ìŠ¤í„°ë§ˆì´ì§•

ì´ì œ ë§¤ë²ˆ ë˜‘ê°™ì€ ëª‡ë°±, ëª‡ì²œì¤„ì˜ ì—‘ì…€ì˜ ì…€ ìŠ¤íƒ€ì¼ì„ ì§œëŠë¼ ê³ ìƒí•  í•„ìš” ì—†ìŠµë‹ˆë‹¤.
ì—‘ì…€ ë‹¤ìš´ë¡œë“œê°€ ê·€ì°®ì§€ ì•Šê³ , ì¦ê±°ì›Œ(?)ì§ˆ ìˆ˜ë„ ìˆì–´ìš”.