---
emoji: 📖
title: Kotlin inline 함수
date: '2024-04-28 15:30:17'
author: 에디
tags: kotlin
categories: kotlin
---

## 제네릭 공변성, 무공변성, 반공변성

Kotlin에서 **인라인 함수**란 함수 선언 앞에 `inline` 키워드를 붙여 만든 함수다. 이 `inline` 키워드가 어떤 의미를 가지며, 왜 사용하는지 간단하게 알아보겠다.

---

### 왜 인라인 함수가 필요할까?

Kotlin에서는 **고차 함수**(다른 함수를 인자로 받거나 반환하는 함수)를 자주 사용한다. 예를 들어, `filter`, `map`, `forEach` 같은 함수들이 대표적이다.

하지만 고차 함수를 사용하면 다음과 같은 성능 오버헤드가 발생할 수 있다.

- **함수 호출 오버헤드**: 함수 호출 자체에도 비용이 든다.
- **람다 객체 생성**: 람다 표현식을 사용할 때마다 새로운 객체가 생성된다.

이런 오버헤드는 작은 규모의 앱에서는 크게 문제되지 않지만, 성능이 중요한 애플리케이션에서는 영향을 줄 수 있다.

---

### 인라인 함수란 무엇인가?

```kotlin
inline fun greet() {
    println("Hello, World!")
}

fun main() {
    greet() // 함수 호출
}
```

위 예시에서 `inline` 키워드를 붙여 `greet` 함수를 인라인 함수로 선언했다.

컴파일러는 `greet()` 호출을 함수 본문으로 대체한다. 즉, 컴파일된 코드는 다음과 같이 된다.

```kotlin
fun main() {
    println("Hello, World!") // greet() 함수의 내용이 그대로 삽입됨
}
```

이렇게 하면 함수 호출이 아니라 함수의 내용이 그대로 코드에 삽입되므로, 함수 호출 오버헤드가 사라진다.

---

### 인라인 함수의 이점

1. **성능 향상**: 함수 호출과 람다 객체 생성에 따른 오버헤드를 줄일 수 있다.
2. **람다 캡처 비용 감소**: 람다가 외부 변수를 캡처하지 않으면 추가적인 객체 생성을 피할 수 있다.

---

### 언제 사용해야 할까?

- **빈번하게 호출되는 작은 고차 함수**: 성능 최적화가 필요한 부분에 유용하다.
- **람다를 인자로 받는 함수**: 특히 람다가 성능에 영향을 줄 수 있는 경우 인라인 함수로 선언하면 좋다.

---

```kotlin
inline fun processNumbers(numbers: List<Int>, action: (Int) -> Unit) {
    for (number in numbers) {
        action(number)
    }
}

fun main() {
    processNumbers(listOf(1, 2, 3)) { println(it) }
}
```

위 코드에서 `processNumbers` 함수는 인라인 함수로 선언되었다. `action`이라는 람다를 인자로 받으며, 이 함수가 인라인됨으로써 람다 객체 생성 비용이 줄어든다.

---

인라인 함수는 성능을 최적화하는 데 도움이 되며, 특히 고차 함수나 람다를 자주 사용하는 코드에서 유용하게 쓰일 수 있다.

```toc

```
